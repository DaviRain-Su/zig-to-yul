//! EVM Bytecode Generator
//!
//! This module transforms EVM IR into raw EVM bytecode. It handles:
//! - Label resolution (forward and backward jumps)
//! - Optimal PUSH instruction selection
//! - Deploy code (constructor) and runtime code linking
//! - Code size validation
//!
//! The generator works in two passes:
//! 1. First pass: Calculate instruction offsets and collect label positions
//! 2. Second pass: Generate bytecode with resolved jump targets

const std = @import("std");
const ir = @import("ir.zig");
const opcodes = @import("opcodes.zig");

pub const Opcode = opcodes.Opcode;
pub const EvmVersion = opcodes.EvmVersion;
pub const Instruction = ir.Instruction;
pub const Label = ir.Label;
pub const LabelId = ir.LabelId;
pub const Contract = ir.Contract;
pub const FunctionDef = ir.FunctionDef;

/// Error types for bytecode generation.
pub const CodegenError = error{
    UndefinedLabel,
    DuplicateLabel,
    CodeTooLarge,
    InvalidJumpTarget,
    StackOverflow,
    StackUnderflow,
    OutOfMemory,
};

/// A pending jump that needs to be resolved.
const PendingJump = struct {
    label_id: LabelId,
    bytecode_pos: usize,
    jump_size: u8, // Number of bytes for the jump address
};

/// Section information for linking.
const Section = struct {
    name: []const u8,
    offset: usize,
    size: usize,
};

/// Result of bytecode generation.
pub const CodegenResult = struct {
    /// The generated bytecode.
    bytecode: []u8,

    /// Source map entries (instruction index -> bytecode offset).
    source_map: []const SourceMapEntry,

    /// The allocator used (for cleanup).
    allocator: std.mem.Allocator,

    pub fn deinit(self: *CodegenResult) void {
        self.allocator.free(self.bytecode);
        self.allocator.free(self.source_map);
    }

    /// Format bytecode as hex string.
    pub fn toHex(self: CodegenResult, allocator: std.mem.Allocator) ![]u8 {
        const hex = try allocator.alloc(u8, self.bytecode.len * 2);
        for (self.bytecode, 0..) |byte, i| {
            _ = std.fmt.bufPrint(hex[i * 2 ..][0..2], "{x:0>2}", .{byte}) catch unreachable;
        }
        return hex;
    }
};

/// Source map entry for debugging.
pub const SourceMapEntry = struct {
    instruction_index: usize,
    bytecode_offset: usize,
    bytecode_length: usize,
};

/// The main bytecode generator.
pub const Codegen = struct {
    allocator: std.mem.Allocator,
    bytecode: std.ArrayList(u8),
    labels: std.AutoHashMap(LabelId, usize),
    pending_jumps: std.ArrayList(PendingJump),
    sections: std.ArrayList(Section),
    source_map: std.ArrayList(SourceMapEntry),
    evm_version: EvmVersion,

    /// Current bytecode offset.
    current_offset: usize = 0,

    pub fn init(allocator: std.mem.Allocator, evm_version: EvmVersion) Codegen {
        return .{
            .allocator = allocator,
            .bytecode = .empty,
            .labels = std.AutoHashMap(LabelId, usize).init(allocator),
            .pending_jumps = .empty,
            .sections = .empty,
            .source_map = .empty,
            .evm_version = evm_version,
        };
    }

    pub fn deinit(self: *Codegen) void {
        self.bytecode.deinit(self.allocator);
        self.labels.deinit();
        self.pending_jumps.deinit(self.allocator);
        self.sections.deinit(self.allocator);
        self.source_map.deinit(self.allocator);
    }

    /// Generate bytecode for a complete contract.
    pub fn generateContract(self: *Codegen, contract: Contract) !CodegenResult {
        // Clear any previous state
        self.bytecode.clearRetainingCapacity();
        self.labels.clearRetainingCapacity();
        self.pending_jumps.clearRetainingCapacity();
        self.source_map.clearRetainingCapacity();
        self.current_offset = 0;

        // Generate deploy code (constructor + runtime copy)
        try self.generateDeployCode(contract);

        // Check code size limit
        if (self.bytecode.items.len > ir.MAX_INITCODE_SIZE) {
            return CodegenError.CodeTooLarge;
        }

        // Resolve all pending jumps
        try self.resolveJumps();

        return .{
            .bytecode = try self.bytecode.toOwnedSlice(self.allocator),
            .source_map = try self.source_map.toOwnedSlice(self.allocator),
            .allocator = self.allocator,
        };
    }

    /// Generate bytecode for a list of instructions (runtime code only).
    pub fn generate(self: *Codegen, instructions: []const Instruction) !CodegenResult {
        // Clear any previous state
        self.bytecode.clearRetainingCapacity();
        self.labels.clearRetainingCapacity();
        self.pending_jumps.clearRetainingCapacity();
        self.source_map.clearRetainingCapacity();
        self.current_offset = 0;

        // First pass: calculate offsets and collect labels
        var offsets = try self.allocator.alloc(usize, instructions.len);
        defer self.allocator.free(offsets);

        var offset: usize = 0;
        for (instructions, 0..) |inst, i| {
            offsets[i] = offset;
            offset += inst.byteSize(self.evm_version);

            // Collect labels
            if (inst == .label) {
                const label = inst.label;
                const result = try self.labels.getOrPut(label.id);
                if (result.found_existing) {
                    return CodegenError.DuplicateLabel;
                }
                result.value_ptr.* = offsets[i];
            }
        }

        // Second pass: generate bytecode
        for (instructions, 0..) |inst, i| {
            const start_offset = self.bytecode.items.len;
            try self.emitInstruction(inst);
            const end_offset = self.bytecode.items.len;

            try self.source_map.append(self.allocator,.{
                .instruction_index = i,
                .bytecode_offset = start_offset,
                .bytecode_length = end_offset - start_offset,
            });
        }

        // Resolve all pending jumps
        try self.resolveJumps();

        // Check code size limit
        if (self.bytecode.items.len > ir.MAX_CODE_SIZE) {
            return CodegenError.CodeTooLarge;
        }

        return .{
            .bytecode = try self.bytecode.toOwnedSlice(self.allocator),
            .source_map = try self.source_map.toOwnedSlice(self.allocator),
            .allocator = self.allocator,
        };
    }

    /// Generate deploy code (initcode).
    fn generateDeployCode(self: *Codegen, contract: Contract) !void {
        // Deploy code structure:
        // 1. Constructor code (if any)
        // 2. Runtime code copy to memory
        // 3. Return runtime code

        const deploy_start = self.bytecode.items.len;

        // Execute constructor if present
        if (contract.constructor) |constructor_code| {
            for (constructor_code) |inst| {
                try self.emitInstruction(inst);
            }
        }

        // Placeholder for runtime code size and offset
        // We'll use PUSH2 for the size (up to 64KB)
        const runtime_size_pos = self.bytecode.items.len;
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
        try self.bytecode.appendNTimes(self.allocator,0, 2); // Placeholder for runtime size

        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.DUP1)); // Duplicate size

        const runtime_offset_pos = self.bytecode.items.len;
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
        try self.bytecode.appendNTimes(self.allocator,0, 2); // Placeholder for runtime offset

        // Memory destination (0)
        if (self.evm_version.hasPush0()) {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
        } else {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
            try self.bytecode.append(self.allocator,0);
        }

        // CODECOPY: dest=0, offset=runtime_offset, size=runtime_size
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.CODECOPY));

        // Return memory destination (0) and size
        if (self.evm_version.hasPush0()) {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
        } else {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
            try self.bytecode.append(self.allocator,0);
        }
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.RETURN));

        // Mark the start of runtime code
        const runtime_start = self.bytecode.items.len;

        // Generate runtime code
        try self.generateRuntimeCode(contract);

        // Calculate runtime code size
        const runtime_size = self.bytecode.items.len - runtime_start;

        // Backpatch runtime size
        self.bytecode.items[runtime_size_pos + 1] = @truncate(runtime_size >> 8);
        self.bytecode.items[runtime_size_pos + 2] = @truncate(runtime_size);

        // Backpatch runtime offset
        self.bytecode.items[runtime_offset_pos + 1] = @truncate(runtime_start >> 8);
        self.bytecode.items[runtime_offset_pos + 2] = @truncate(runtime_start);

        _ = deploy_start;
    }

    /// Generate runtime code (dispatches to functions).
    fn generateRuntimeCode(self: *Codegen, contract: Contract) !void {
        // Reset labels for runtime section
        self.labels.clearRetainingCapacity();

        // Generate function dispatcher
        try self.generateDispatcher(contract.functions);

        // Generate each function body
        for (contract.functions) |func| {
            // Define function label
            try self.labels.put(func.selector, self.bytecode.items.len);
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.JUMPDEST));

            // Emit function body
            for (func.body) |inst| {
                try self.emitInstruction(inst);
            }
        }

        // Generate fallback if present
        if (contract.fallback) |fallback_code| {
            try self.labels.put(0xFFFFFFFF, self.bytecode.items.len); // Special fallback label
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.JUMPDEST));
            for (fallback_code) |inst| {
                try self.emitInstruction(inst);
            }
        }

        // Generate receive if present (for receiving ether)
        if (contract.receive) |receive_code| {
            try self.labels.put(0xFFFFFFFE, self.bytecode.items.len); // Special receive label
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.JUMPDEST));
            for (receive_code) |inst| {
                try self.emitInstruction(inst);
            }
        }
    }

    /// Generate the function dispatcher.
    fn generateDispatcher(self: *Codegen, functions: []const FunctionDef) !void {
        // Get function selector: calldataload(0) >> 224
        if (self.evm_version.hasPush0()) {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
        } else {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
            try self.bytecode.append(self.allocator,0);
        }
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.CALLDATALOAD));

        // Shift right by 224 bits to get 4-byte selector
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
        try self.bytecode.append(self.allocator,224);
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.SHR));

        // Compare against each function selector
        for (functions) |func| {
            // DUP1 (duplicate selector)
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.DUP1));

            // PUSH4 selector
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH4));
            try self.bytecode.append(self.allocator,@truncate(func.selector >> 24));
            try self.bytecode.append(self.allocator,@truncate(func.selector >> 16));
            try self.bytecode.append(self.allocator,@truncate(func.selector >> 8));
            try self.bytecode.append(self.allocator,@truncate(func.selector));

            // EQ
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.EQ));

            // PUSH2 target (placeholder)
            try self.pending_jumps.append(self.allocator,.{
                .label_id = func.selector,
                .bytecode_pos = self.bytecode.items.len + 1,
                .jump_size = 2,
            });
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
            try self.bytecode.appendNTimes(self.allocator,0, 2);

            // JUMPI
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.JUMPI));
        }

        // No match: revert with empty data
        if (self.evm_version.hasPush0()) {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
        } else {
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
            try self.bytecode.append(self.allocator,0);
            try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
            try self.bytecode.append(self.allocator,0);
        }
        try self.bytecode.append(self.allocator,@intFromEnum(Opcode.REVERT));
    }

    /// Emit a single instruction to bytecode.
    fn emitInstruction(self: *Codegen, inst: Instruction) !void {
        switch (inst) {
            .opcode => |op| {
                try self.bytecode.append(self.allocator,@intFromEnum(op));
            },
            .push => |value| {
                try self.emitPush(value);
            },
            .push_small => |value| {
                if (value == 0 and self.evm_version.hasPush0()) {
                    try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
                } else {
                    try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
                    try self.bytecode.append(self.allocator,value);
                }
            },
            .label => |label| {
                // Record label position (may already exist from generate's first pass)
                const result = try self.labels.getOrPut(label.id);
                if (!result.found_existing) {
                    result.value_ptr.* = self.bytecode.items.len;
                }
                // Emit JUMPDEST
                try self.bytecode.append(self.allocator, @intFromEnum(Opcode.JUMPDEST));
            },
            .jump => |target| {
                // PUSH2 address + JUMP
                try self.pending_jumps.append(self.allocator,.{
                    .label_id = target.id,
                    .bytecode_pos = self.bytecode.items.len + 1,
                    .jump_size = 2,
                });
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
                try self.bytecode.appendNTimes(self.allocator,0, 2);
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.JUMP));
            },
            .jumpi => |target| {
                // PUSH2 address + JUMPI
                try self.pending_jumps.append(self.allocator,.{
                    .label_id = target.id,
                    .bytecode_pos = self.bytecode.items.len + 1,
                    .jump_size = 2,
                });
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
                try self.bytecode.appendNTimes(self.allocator,0, 2);
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.JUMPI));
            },
            .label_ref => |target| {
                // Just push the label address
                try self.pending_jumps.append(self.allocator,.{
                    .label_id = target.id,
                    .bytecode_pos = self.bytecode.items.len + 1,
                    .jump_size = 2,
                });
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
                try self.bytecode.appendNTimes(self.allocator,0, 2);
            },
            .datasize, .dataoffset => {
                // These are resolved during linking
                // For now, emit placeholder
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH2));
                try self.bytecode.appendNTimes(self.allocator,0, 2);
            },
            .datacopy => |_| {
                // CODECOPY pattern - resolved during linking
            },
            .raw_bytes => |bytes| {
                try self.bytecode.appendSlice(self.allocator,bytes);
            },
            .comment, .var_annotation => {
                // No bytecode generated
            },
        }
    }

    /// Emit a PUSH instruction with automatic size selection.
    fn emitPush(self: *Codegen, value: u256) !void {
        if (value == 0) {
            if (self.evm_version.hasPush0()) {
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH0));
            } else {
                try self.bytecode.append(self.allocator,@intFromEnum(Opcode.PUSH1));
                try self.bytecode.append(self.allocator,0);
            }
            return;
        }

        // Calculate bytes needed
        const byte_count = ir.bytesNeeded(value);

        // Emit PUSH opcode (PUSH1 = 0x60, PUSH32 = 0x7f)
        try self.bytecode.append(self.allocator,@truncate(0x5f + byte_count));

        // Emit value in big-endian order
        var i: usize = byte_count;
        while (i > 0) {
            i -= 1;
            const byte: u8 = @truncate(value >> (@as(u8, @intCast(i)) * 8));
            try self.bytecode.append(self.allocator,byte);
        }
    }

    /// Resolve all pending jump targets.
    fn resolveJumps(self: *Codegen) !void {
        for (self.pending_jumps.items) |jump| {
            const target = self.labels.get(jump.label_id) orelse {
                return CodegenError.UndefinedLabel;
            };

            // Validate target is a JUMPDEST
            if (target < self.bytecode.items.len and
                self.bytecode.items[target] != @intFromEnum(Opcode.JUMPDEST))
            {
                return CodegenError.InvalidJumpTarget;
            }

            // Write target address in big-endian
            if (jump.jump_size == 2) {
                if (target > 0xFFFF) {
                    return CodegenError.CodeTooLarge;
                }
                self.bytecode.items[jump.bytecode_pos] = @truncate(target >> 8);
                self.bytecode.items[jump.bytecode_pos + 1] = @truncate(target);
            } else if (jump.jump_size == 3) {
                if (target > 0xFFFFFF) {
                    return CodegenError.CodeTooLarge;
                }
                self.bytecode.items[jump.bytecode_pos] = @truncate(target >> 16);
                self.bytecode.items[jump.bytecode_pos + 1] = @truncate(target >> 8);
                self.bytecode.items[jump.bytecode_pos + 2] = @truncate(target);
            }
        }
    }

    /// Get the current bytecode as a slice (before finalization).
    pub fn currentBytecode(self: *Codegen) []const u8 {
        return self.bytecode.items;
    }

    /// Get the current bytecode length.
    pub fn currentLength(self: *Codegen) usize {
        return self.bytecode.items.len;
    }
};

// =============================================
// Utilities
// =============================================

/// Disassemble bytecode back to opcodes (for debugging).
pub fn disassemble(allocator: std.mem.Allocator, bytecode: []const u8) ![]const DisassembledOp {
    var ops: std.ArrayList(DisassembledOp) = .empty;
    errdefer ops.deinit(allocator);

    var i: usize = 0;
    while (i < bytecode.len) {
        const op_byte = bytecode[i];
        const op: Opcode = @enumFromInt(op_byte);
        const imm_size = op.immediateSize();

        var immediate: ?[]const u8 = null;
        if (imm_size > 0 and i + imm_size < bytecode.len) {
            immediate = bytecode[i + 1 .. i + 1 + imm_size];
        }

        try ops.append(allocator, .{
            .offset = i,
            .opcode = op,
            .immediate = immediate,
        });

        i += 1 + imm_size;
    }

    return ops.toOwnedSlice(allocator);
}

pub const DisassembledOp = struct {
    offset: usize,
    opcode: Opcode,
    immediate: ?[]const u8,

    pub fn format(
        self: DisassembledOp,
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        try writer.print("{x:0>4}: {s}", .{ self.offset, @tagName(self.opcode) });
        if (self.immediate) |imm| {
            try writer.writeAll(" 0x");
            for (imm) |b| {
                try writer.print("{x:0>2}", .{b});
            }
        }
    }
};

// =============================================
// Tests
// =============================================

test "generate simple push and add" {
    var codegen = Codegen.init(std.testing.allocator, .cancun);
    defer codegen.deinit();

    const instructions = [_]Instruction{
        .{ .push = 10 },
        .{ .push = 20 },
        .{ .opcode = .ADD },
        .{ .opcode = .STOP },
    };

    var result = try codegen.generate(&instructions);
    defer result.deinit();

    // PUSH1 10 + PUSH1 20 + ADD + STOP = 2 + 2 + 1 + 1 = 6 bytes
    try std.testing.expectEqual(@as(usize, 6), result.bytecode.len);

    // Verify: PUSH1 0x0a PUSH1 0x14 ADD STOP
    try std.testing.expectEqual(@as(u8, 0x60), result.bytecode[0]); // PUSH1
    try std.testing.expectEqual(@as(u8, 10), result.bytecode[1]);
    try std.testing.expectEqual(@as(u8, 0x60), result.bytecode[2]); // PUSH1
    try std.testing.expectEqual(@as(u8, 20), result.bytecode[3]);
    try std.testing.expectEqual(@as(u8, 0x01), result.bytecode[4]); // ADD
    try std.testing.expectEqual(@as(u8, 0x00), result.bytecode[5]); // STOP
}

test "generate with labels" {
    var codegen = Codegen.init(std.testing.allocator, .cancun);
    defer codegen.deinit();

    const loop_label = Label{ .id = 0, .name = "loop" };

    const instructions = [_]Instruction{
        .{ .label = loop_label },
        .{ .push = 1 },
        .{ .jump = loop_label },
    };

    var result = try codegen.generate(&instructions);
    defer result.deinit();

    // JUMPDEST + PUSH1 1 + PUSH2 addr + JUMP
    // = 1 + 2 + 3 + 1 = 7 bytes
    try std.testing.expectEqual(@as(usize, 7), result.bytecode.len);

    // Verify JUMPDEST at position 0
    try std.testing.expectEqual(@as(u8, 0x5b), result.bytecode[0]); // JUMPDEST

    // Verify jump target points to 0
    try std.testing.expectEqual(@as(u8, 0x00), result.bytecode[4]); // High byte
    try std.testing.expectEqual(@as(u8, 0x00), result.bytecode[5]); // Low byte
}

test "push0 optimization" {
    // Shanghai has PUSH0
    var codegen_shanghai = Codegen.init(std.testing.allocator, .shanghai);
    defer codegen_shanghai.deinit();

    const instructions = [_]Instruction{
        .{ .push = 0 },
        .{ .opcode = .STOP },
    };

    var result = try codegen_shanghai.generate(&instructions);
    defer result.deinit();

    // PUSH0 + STOP = 2 bytes
    try std.testing.expectEqual(@as(usize, 2), result.bytecode.len);
    try std.testing.expectEqual(@as(u8, 0x5f), result.bytecode[0]); // PUSH0

    // London doesn't have PUSH0
    var codegen_london = Codegen.init(std.testing.allocator, .london);
    defer codegen_london.deinit();

    var result2 = try codegen_london.generate(&instructions);
    defer result2.deinit();

    // PUSH1 0 + STOP = 3 bytes
    try std.testing.expectEqual(@as(usize, 3), result2.bytecode.len);
    try std.testing.expectEqual(@as(u8, 0x60), result2.bytecode[0]); // PUSH1
}

test "push size selection" {
    var codegen = Codegen.init(std.testing.allocator, .cancun);
    defer codegen.deinit();

    const instructions = [_]Instruction{
        .{ .push = 0xff }, // 1 byte
        .{ .push = 0x100 }, // 2 bytes
        .{ .push = 0x10000 }, // 3 bytes
        .{ .opcode = .STOP },
    };

    var result = try codegen.generate(&instructions);
    defer result.deinit();

    // PUSH1 (2) + PUSH2 (3) + PUSH3 (4) + STOP (1) = 10 bytes
    try std.testing.expectEqual(@as(usize, 10), result.bytecode.len);

    try std.testing.expectEqual(@as(u8, 0x60), result.bytecode[0]); // PUSH1
    try std.testing.expectEqual(@as(u8, 0x61), result.bytecode[2]); // PUSH2
    try std.testing.expectEqual(@as(u8, 0x62), result.bytecode[5]); // PUSH3
}

test "disassemble" {
    const bytecode = [_]u8{
        0x60, 0x0a, // PUSH1 10
        0x60, 0x14, // PUSH1 20
        0x01, // ADD
        0x00, // STOP
    };

    const ops = try disassemble(std.testing.allocator, &bytecode);
    defer std.testing.allocator.free(ops);

    try std.testing.expectEqual(@as(usize, 4), ops.len);
    try std.testing.expectEqual(Opcode.PUSH1, ops[0].opcode);
    try std.testing.expectEqual(Opcode.PUSH1, ops[1].opcode);
    try std.testing.expectEqual(Opcode.ADD, ops[2].opcode);
    try std.testing.expectEqual(Opcode.STOP, ops[3].opcode);
}
