//! Direct EVM Bytecode Compiler
//!
//! This module provides the complete compilation pipeline from Yul AST
//! directly to EVM bytecode, without requiring solc.
//!
//! Pipeline: Yul AST → EVM IR → EVM Bytecode
//!
//! Usage:
//! ```zig
//! var compiler = BytecodeCompiler.init(allocator, .cancun);
//! defer compiler.deinit();
//!
//! const result = try compiler.compile(yul_ast);
//! defer result.deinit();
//!
//! std.debug.print("Bytecode: 0x{s}\n", .{result.toHex()});
//! ```

const std = @import("std");
const yul_ast = @import("../yul/ast.zig");
const ir = @import("ir.zig");
const codegen = @import("codegen.zig");
const from_yul = @import("from_yul.zig");
const opcodes = @import("opcodes.zig");

pub const Opcode = opcodes.Opcode;
pub const EvmVersion = opcodes.EvmVersion;
pub const CodegenResult = codegen.CodegenResult;

/// Compilation options.
pub const CompileOptions = struct {
    /// Target EVM version.
    evm_version: EvmVersion = .cancun,

    /// Whether to optimize the generated code.
    optimize: bool = false,

    /// Whether to include constructor (deploy code).
    include_deploy_code: bool = true,

    /// Maximum code size (0 = no limit check).
    max_code_size: usize = ir.MAX_CODE_SIZE,
};

/// Compilation result containing bytecode and metadata.
pub const CompileResult = struct {
    /// The generated bytecode.
    bytecode: []u8,

    /// Runtime code offset (if deploy code is included).
    runtime_offset: usize,

    /// Runtime code size.
    runtime_size: usize,

    /// The allocator used.
    allocator: std.mem.Allocator,

    pub fn deinit(self: *CompileResult) void {
        self.allocator.free(self.bytecode);
    }

    /// Get the runtime bytecode only (without deploy code).
    pub fn runtimeBytecode(self: *const CompileResult) []const u8 {
        return self.bytecode[self.runtime_offset..][0..self.runtime_size];
    }

    /// Format bytecode as hex string.
    pub fn toHex(self: *const CompileResult, allocator: std.mem.Allocator) ![]u8 {
        const hex = try allocator.alloc(u8, self.bytecode.len * 2);
        for (self.bytecode, 0..) |byte, i| {
            _ = std.fmt.bufPrint(hex[i * 2 ..][0..2], "{x:0>2}", .{byte}) catch unreachable;
        }
        return hex;
    }

    /// Format runtime bytecode as hex string.
    pub fn runtimeToHex(self: *const CompileResult, allocator: std.mem.Allocator) ![]u8 {
        const runtime = self.runtimeBytecode();
        const hex = try allocator.alloc(u8, runtime.len * 2);
        for (runtime, 0..) |byte, i| {
            _ = std.fmt.bufPrint(hex[i * 2 ..][0..2], "{x:0>2}", .{byte}) catch unreachable;
        }
        return hex;
    }
};

/// Error types for the bytecode compiler.
pub const CompilerError = error{
    TransformFailed,
    CodegenFailed,
    CodeTooLarge,
    InvalidInput,
    OutOfMemory,
};

/// Direct EVM bytecode compiler.
pub const BytecodeCompiler = struct {
    allocator: std.mem.Allocator,
    options: CompileOptions,

    pub fn init(allocator: std.mem.Allocator, evm_version: EvmVersion) BytecodeCompiler {
        return .{
            .allocator = allocator,
            .options = .{ .evm_version = evm_version },
        };
    }

    pub fn initWithOptions(allocator: std.mem.Allocator, options: CompileOptions) BytecodeCompiler {
        return .{
            .allocator = allocator,
            .options = options,
        };
    }

    /// Compile a Yul AST to EVM bytecode.
    pub fn compile(self: *BytecodeCompiler, ast: yul_ast.AST) CompilerError!CompileResult {
        return self.compileObject(ast.root);
    }

    /// Compile a Yul Object to EVM bytecode.
    pub fn compileObject(self: *BytecodeCompiler, obj: yul_ast.Object) CompilerError!CompileResult {
        // Step 1: Transform Yul AST to EVM IR
        const instructions = from_yul.transformObject(
            self.allocator,
            obj,
            self.options.evm_version,
        ) catch |err| {
            std.debug.print("Transform error: {}\n", .{err});
            return CompilerError.TransformFailed;
        };
        defer self.allocator.free(instructions);

        // Step 2: Generate bytecode from IR
        var cg = codegen.Codegen.init(self.allocator, self.options.evm_version);
        defer cg.deinit();

        const result = cg.generate(instructions) catch |err| {
            std.debug.print("Codegen error: {}\n", .{err});
            return CompilerError.CodegenFailed;
        };
        // Free source_map since we only need bytecode for CompileResult
        defer self.allocator.free(result.source_map);

        // Step 3: Check code size limit
        if (self.options.max_code_size > 0 and result.bytecode.len > self.options.max_code_size) {
            self.allocator.free(result.bytecode);
            return CompilerError.CodeTooLarge;
        }

        return .{
            .bytecode = result.bytecode,
            .runtime_offset = 0,
            .runtime_size = result.bytecode.len,
            .allocator = self.allocator,
        };
    }

    /// Compile a Yul AST to EVM bytecode with deploy code.
    pub fn compileWithDeployCode(
        self: *BytecodeCompiler,
        ast: yul_ast.AST,
    ) CompilerError!CompileResult {
        // For contracts with sub-objects, the main code is deploy code
        // and the first sub-object named "<ContractName>_deployed" is runtime code

        const obj = ast.root;

        // Find the runtime code sub-object
        var runtime_obj: ?yul_ast.Object = null;
        for (obj.sub_objects) |sub| {
            if (std.mem.endsWith(u8, sub.name, "_deployed")) {
                runtime_obj = sub;
                break;
            }
        }

        if (runtime_obj) |runtime| {
            // Compile runtime code first
            const runtime_instructions = from_yul.transformObject(
                self.allocator,
                runtime,
                self.options.evm_version,
            ) catch return CompilerError.TransformFailed;
            defer self.allocator.free(runtime_instructions);

            var runtime_cg = codegen.Codegen.init(self.allocator, self.options.evm_version);
            defer runtime_cg.deinit();

            var runtime_result = runtime_cg.generate(runtime_instructions) catch
                return CompilerError.CodegenFailed;
            defer runtime_result.deinit();

            // Now generate deploy code that includes the runtime code
            const deploy_code = try self.generateDeployCode(
                obj.code,
                runtime_result.bytecode,
            );

            return .{
                .bytecode = deploy_code,
                .runtime_offset = deploy_code.len - runtime_result.bytecode.len,
                .runtime_size = runtime_result.bytecode.len,
                .allocator = self.allocator,
            };
        } else {
            // No sub-object, compile as simple contract
            return self.compileObject(obj);
        }
    }

    /// Generate deploy code (initcode) that includes runtime code.
    fn generateDeployCode(
        self: *BytecodeCompiler,
        constructor_block: yul_ast.Block,
        runtime_bytecode: []const u8,
    ) CompilerError![]u8 {
        var code = std.ArrayList(u8).init(self.allocator);
        errdefer code.deinit();

        // Transform constructor code if not empty
        if (constructor_block.statements.len > 0) {
            const constructor_ir = from_yul.transform(
                self.allocator,
                yul_ast.AST.init(yul_ast.Object.init("constructor", constructor_block, &.{}, &.{})),
                self.options.evm_version,
            ) catch return CompilerError.TransformFailed;
            defer self.allocator.free(constructor_ir);

            var constructor_cg = codegen.Codegen.init(self.allocator, self.options.evm_version);
            defer constructor_cg.deinit();

            var constructor_result = constructor_cg.generate(constructor_ir) catch
                return CompilerError.CodegenFailed;
            defer constructor_result.deinit();

            code.appendSlice(constructor_result.bytecode) catch
                return CompilerError.OutOfMemory;
        }

        // Calculate sizes
        const runtime_size = runtime_bytecode.len;
        const runtime_offset = code.items.len + 13; // Size of the copy instructions below

        // Generate code to copy runtime to memory and return it
        // PUSH2 runtime_size
        code.append(0x61) catch return CompilerError.OutOfMemory;
        code.append(@truncate(runtime_size >> 8)) catch return CompilerError.OutOfMemory;
        code.append(@truncate(runtime_size)) catch return CompilerError.OutOfMemory;

        // DUP1 (for RETURN later)
        code.append(0x80) catch return CompilerError.OutOfMemory;

        // PUSH2 runtime_offset
        code.append(0x61) catch return CompilerError.OutOfMemory;
        code.append(@truncate(runtime_offset >> 8)) catch return CompilerError.OutOfMemory;
        code.append(@truncate(runtime_offset)) catch return CompilerError.OutOfMemory;

        // PUSH1 0 (memory destination)
        if (self.options.evm_version.hasPush0()) {
            code.append(0x5f) catch return CompilerError.OutOfMemory; // PUSH0
        } else {
            code.append(0x60) catch return CompilerError.OutOfMemory; // PUSH1
            code.append(0) catch return CompilerError.OutOfMemory;
        }

        // CODECOPY
        code.append(0x39) catch return CompilerError.OutOfMemory;

        // PUSH1 0 (memory offset for RETURN)
        if (self.options.evm_version.hasPush0()) {
            code.append(0x5f) catch return CompilerError.OutOfMemory;
        } else {
            code.append(0x60) catch return CompilerError.OutOfMemory;
            code.append(0) catch return CompilerError.OutOfMemory;
        }

        // RETURN
        code.append(0xf3) catch return CompilerError.OutOfMemory;

        // Append runtime bytecode
        code.appendSlice(runtime_bytecode) catch return CompilerError.OutOfMemory;

        return code.toOwnedSlice() catch return CompilerError.OutOfMemory;
    }
};

// =============================================
// Convenience Functions
// =============================================

/// Compile a Yul AST directly to bytecode hex string.
pub fn compileToHex(
    allocator: std.mem.Allocator,
    ast: yul_ast.AST,
    evm_version: EvmVersion,
) ![]u8 {
    var compiler = BytecodeCompiler.init(allocator, evm_version);
    var result = try compiler.compile(ast);
    defer result.deinit();
    return result.toHex(allocator);
}

/// Compile a Yul Object directly to bytecode hex string.
pub fn compileObjectToHex(
    allocator: std.mem.Allocator,
    obj: yul_ast.Object,
    evm_version: EvmVersion,
) ![]u8 {
    var compiler = BytecodeCompiler.init(allocator, evm_version);
    var result = try compiler.compileObject(obj);
    defer result.deinit();
    return result.toHex(allocator);
}

// =============================================
// Tests
// =============================================

test "compile simple add" {
    const allocator = std.testing.allocator;

    // Build a simple Yul AST: { let x := add(1, 2) }
    const ast = yul_ast.AST.init(yul_ast.Object.init(
        "Test",
        yul_ast.Block.init(&.{
            yul_ast.Statement.varDecl(
                &.{yul_ast.TypedName.init("x")},
                yul_ast.Expression.builtinCall("add", &.{
                    yul_ast.Expression.lit(yul_ast.Literal.number(1)),
                    yul_ast.Expression.lit(yul_ast.Literal.number(2)),
                }),
            ),
            yul_ast.Statement.expr(
                yul_ast.Expression.builtinCall("stop", &.{}),
            ),
        }),
        &.{},
        &.{},
    ));

    var compiler = BytecodeCompiler.init(allocator, .cancun);
    var result = try compiler.compile(ast);
    defer result.deinit();

    // Should have generated some bytecode
    try std.testing.expect(result.bytecode.len > 0);
}

test "compile with push0" {
    const allocator = std.testing.allocator;

    // Simple: { mstore(0, 42) stop() }
    const ast = yul_ast.AST.init(yul_ast.Object.init(
        "Test",
        yul_ast.Block.init(&.{
            yul_ast.Statement.expr(
                yul_ast.Expression.builtinCall("mstore", &.{
                    yul_ast.Expression.lit(yul_ast.Literal.number(0)),
                    yul_ast.Expression.lit(yul_ast.Literal.number(42)),
                }),
            ),
            yul_ast.Statement.expr(
                yul_ast.Expression.builtinCall("stop", &.{}),
            ),
        }),
        &.{},
        &.{},
    ));

    // Shanghai has PUSH0
    var compiler_shanghai = BytecodeCompiler.init(allocator, .shanghai);
    var result_shanghai = try compiler_shanghai.compile(ast);
    defer result_shanghai.deinit();

    // London doesn't have PUSH0
    var compiler_london = BytecodeCompiler.init(allocator, .london);
    var result_london = try compiler_london.compile(ast);
    defer result_london.deinit();

    // Shanghai should use PUSH0 (smaller code)
    try std.testing.expect(result_shanghai.bytecode.len <= result_london.bytecode.len);
}

test "hex output" {
    const allocator = std.testing.allocator;

    const ast = yul_ast.AST.init(yul_ast.Object.init(
        "Test",
        yul_ast.Block.init(&.{
            yul_ast.Statement.expr(
                yul_ast.Expression.builtinCall("stop", &.{}),
            ),
        }),
        &.{},
        &.{},
    ));

    const hex = try compileToHex(allocator, ast, .cancun);
    defer allocator.free(hex);

    // Should be valid hex (even length, only hex chars)
    try std.testing.expect(hex.len % 2 == 0);
    for (hex) |c| {
        try std.testing.expect((c >= '0' and c <= '9') or (c >= 'a' and c <= 'f'));
    }
}
