//! Source: z2y tool (no Rust reference)
const std = @import("std");

const Template = struct {
    const build_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) void {
        \\    const target = b.standardTargetOptions(.{});
        \\    const optimize = b.standardOptimizeOption(.{});
        \\
        \\    const zig_to_yul = b.dependency("zig_to_yul", .{
        \\        .target = target,
        \\        .optimize = optimize,
        \\    });
        \\
        \\    const evm_mod = b.createModule(.{
        \\        .root_source_file = b.path("src/evm.zig"),
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .imports = &.{
        \\            .{ .name = "zig_to_yul", .module = zig_to_yul.module("zig_to_yul") },
        \\        },
        \\    });
        \\
        \\    // Provide root_source_file and module imports for --project.
        \\    const contract_mod = b.createModule(.{
        \\        .root_source_file = b.path("src/Contract.zig"),
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .imports = &.{
        \\            .{ .name = "evm", .module = evm_mod },
        \\        },
        \\    });
        \\    _ = contract_mod;
        \\
        \\    const compile_step = b.addSystemCommand(&.{
        \\        "zig-to-yul",
        \\        "compile",
        \\        "--project",
        \\        ".",
        \\        "--abi",
        \\        "out/Contract.abi.json",
        \\        "-o",
        \\        "out/Contract.yul",
        \\        "src/Contract.zig",
        \\    });
        \\
        \\    const solc_step = b.addSystemCommand(&.{
        \\        "solc",
        \\        "--strict-assembly",
        \\        "--bin",
        \\        "out/Contract.yul",
        \\        "-o",
        \\        "out",
        \\    });
        \\    solc_step.step.dependOn(&compile_step.step);
        \\
        \\    const contract_step = b.step("contract", "Build contract bytecode");
        \\    contract_step.dependOn(&solc_step.step);
        \\    b.getInstallStep().dependOn(&solc_step.step);
        \\}
    ;

    const build_zig_zon =
        \\// Generated by z2y. Use `zig fetch --save` to add dependencies.
        \\// See: https://ziglang.org/learn/build-system/#package-management
        \\.{
        \\    .name = .contract,
        \\    .version = "0.1.0",
        \\    .fingerprint = 0x0000000000000001,
        \\    .minimum_zig_version = "0.15.2",
        \\    .paths = .{"."},
        \\    .dependencies = .{
        \\        .zig_to_yul = .{
        \\            .url = "https://github.com/DaviRain-Su/zig-to-yul/archive/refs/heads/main.tar.gz",
        \\            .hash = "zig_to_yul-0.0.0-Gzz9gPBbCQCeGdLoAHlmk4bZvxtzRt1xWYqNsrVq4Eg1",
        \\        },
        \\    },
        \\}
    ;

    const evm_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const sdk = @import("zig_to_yul").evm;
        \\
        \\pub const types = sdk.types;
        \\pub const event_decode = sdk.event_decode;
        \\pub const event_encode = sdk.event_encode;
        \\pub const builtins = sdk.builtins;
        \\pub const U256 = sdk.U256;
        \\pub const Address = sdk.Address;
        \\pub const EvmType = sdk.EvmType;
    ;

    const contract_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const evm = @import("evm");
        \\
        \\pub const Contract = struct {
        \\    value: evm.U256,
        \\
        \\    pub fn set(self: *Contract, next: evm.U256) void {
        \\        self.value = next;
        \\    }
        \\
        \\    pub fn get(self: *Contract) evm.U256 {
        \\        return self.value;
        \\    }
        \\
        \\    pub fn add(self: *Contract, delta: evm.U256) evm.U256 {
        \\        self.value = self.value + delta;
        \\        return self.value;
        \\    }
        \\};
    ;
};

const default_rpc_url = "http://localhost:8545";
const default_anvil_private_key = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
const default_private_key_env = "PRIVATE_KEY";

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        try printUsage();
        return;
    }

    const command = args[1];
    if (std.mem.eql(u8, command, "init")) {
        const target_dir = if (args.len >= 3) args[2] else ".";
        if (args.len > 3) {
            try printUsage();
            return;
        }
        try initProject(allocator, target_dir);
        return;
    }

    if (std.mem.eql(u8, command, "install")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try printInstallInstructions();
        return;
    }

    if (std.mem.eql(u8, command, "info")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try printToolInfo(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "build-abi")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try buildAbi(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "test")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try runLocalTest(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "deploy")) {
        var rpc_url: ?[]const u8 = null;
        var profile_name: ?[]const u8 = null;
        var i: usize = 2;
        while (i < args.len) : (i += 1) {
            const arg = args[i];
            if (std.mem.eql(u8, arg, "--rpc-url")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                rpc_url = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--profile")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                profile_name = args[i];
                continue;
            }
            try printUsage();
            return;
        }
        var resolved = try resolveRpcSettings(allocator, profile_name, rpc_url);
        defer resolved.deinit(allocator);
        try deployRemote(allocator, resolved.rpc_url, resolved.private_key_env);
        return;
    }

    if (std.mem.eql(u8, command, "call")) {
        var rpc_url: ?[]const u8 = null;
        var profile_name: ?[]const u8 = null;
        var address: ?[]const u8 = null;
        var signature: ?[]const u8 = null;
        var abi_path: ?[]const u8 = null;
        var func_name: ?[]const u8 = null;
        var args_start: ?usize = null;

        var i: usize = 2;
        while (i < args.len) : (i += 1) {
            const arg = args[i];
            if (std.mem.eql(u8, arg, "--rpc-url")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                rpc_url = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--profile")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                profile_name = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--address")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                address = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--sig")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                signature = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--abi")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                abi_path = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--func")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                func_name = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--args")) {
                args_start = i + 1;
                break;
            }
            try printUsage();
            return;
        }

        if (address == null) {
            try printUsage();
            return;
        }

        var resolved = try resolveRpcSettings(allocator, profile_name, rpc_url);
        defer resolved.deinit(allocator);

        var owned_signature: ?[]u8 = null;
        if (signature == null) {
            if (abi_path == null or func_name == null) {
                try printUsage();
                return;
            }
            owned_signature = try signatureFromAbi(allocator, abi_path.?, func_name.?);
            signature = owned_signature;
        }
        defer if (owned_signature) |sig| allocator.free(sig);

        const call_args = if (args_start) |start| args[start..] else &.{};
        const output = try castCallArgs(allocator, resolved.rpc_url, address.?, signature.?, call_args);
        defer allocator.free(output);

        var stdout_buffer: [1024]u8 = undefined;
        var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
        const stdout: *std.Io.Writer = &stdout_writer.interface;
        try stdout.print("{s}\n", .{std.mem.trim(u8, output, " \n\r\t")});
        try stdout.flush();
        return;
    }

    if (std.mem.eql(u8, command, "build")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        const output = try buildBytecode(allocator);
        defer allocator.free(output);

        var stdout_buffer: [1024]u8 = undefined;
        var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
        const stdout: *std.Io.Writer = &stdout_writer.interface;
        try stdout.print("Bytecode written: out/Contract.bin\n", .{});
        try stdout.flush();
        return;
    }

    if (std.mem.eql(u8, command, "profile-test")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try runProfileTest(allocator);
        return;
    }

    try printUsage();
}

fn printUsage() !void {
    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print(
        "Usage:\n" ++
            "  z2y init [dir]\n" ++
            "  z2y install\n" ++
            "  z2y info\n" ++
            "  z2y build\n" ++
            "  z2y build-abi\n" ++
            "  z2y test\n" ++
            "  z2y profile-test\n" ++
            "  z2y deploy [--rpc-url <url> | --profile <name>]\n" ++
            "  z2y call --address <addr> (--sig <signature> | --abi <file> --func <name>) [--args ...] [--rpc-url <url> | --profile <name>]\n",
        .{},
    );

    try stdout.flush();
}

fn printInstallInstructions() !void {
    const builtin = @import("builtin");
    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;

    try stdout.print("Required tools:\n", .{});
    try stdout.print("- Zig 0.15.x\n", .{});
    try stdout.print("- solc (Solidity compiler)\n", .{});
    try stdout.print("- zig-to-yul binary in PATH\n", .{});
    try stdout.print("- Foundry (anvil/forge/cast)\n", .{});
    try stdout.print("- profiles.json (optional, for named RPC profiles)\n\n", .{});

    switch (builtin.os.tag) {
        .macos => {
            try stdout.print("Install Zig (macOS):\n  brew install zig\n", .{});
        },
        .linux => {
            try stdout.print("Install Zig (Linux):\n  https://ziglang.org/download/\n", .{});
        },
        .windows => {
            try stdout.print("Install Zig (Windows):\n  choco install zig\n", .{});
        },
        else => {
            try stdout.print("Install Zig:\n  https://ziglang.org/download/\n", .{});
        },
    }

    try stdout.print("\nInstall solc:\n  npm install -g solc\n", .{});
    try stdout.print("\nInstall Foundry (anvil/forge):\n  curl -L https://foundry.paradigm.xyz | bash\n  foundryup\n", .{});
    try stdout.print("\nInstall zig-to-yul (needed for compilation):\n  git clone git@github.com:DaviRain-Su/zig-to-yul.git\n  cd zig-to-yul\n  zig build -Doptimize=ReleaseFast\n\n", .{});
    try stdout.print("Add to PATH:\n  export PATH=\"$PWD/zig-out/bin:$PATH\"\n", .{});
    try stdout.flush();
}

fn printToolInfo(allocator: std.mem.Allocator) !void {
    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;

    try printToolStatus(allocator, stdout, "zig");
    try printToolStatus(allocator, stdout, "zig-to-yul");
    try printToolStatus(allocator, stdout, "solc");
    try printToolStatus(allocator, stdout, "anvil");
    try printToolStatus(allocator, stdout, "forge");
    try printToolStatus(allocator, stdout, "cast");
    try stdout.flush();
}

fn printToolStatus(allocator: std.mem.Allocator, stdout: *std.Io.Writer, name: []const u8) !void {
    const path = try findExecutablePath(allocator, name);
    defer if (path) |p| allocator.free(p);

    if (path) |p| {
        try stdout.print("{s}: found ({s})\n", .{ name, p });
    } else {
        try stdout.print("{s}: missing\n", .{name});
    }
}

fn findExecutablePath(allocator: std.mem.Allocator, name: []const u8) !?[]u8 {
    const builtin = @import("builtin");
    const path_value = std.process.getEnvVarOwned(allocator, "PATH") catch |err| switch (err) {
        error.EnvironmentVariableNotFound => return null,
        else => return err,
    };
    defer allocator.free(path_value);

    var it = std.mem.splitScalar(u8, path_value, std.fs.path.delimiter);
    while (it.next()) |dir| {
        if (dir.len == 0) continue;

        if (builtin.os.tag == .windows) {
            if (try checkExecutableCandidate(allocator, dir, name)) |found| return found;
            const exe_name = try std.fmt.allocPrint(allocator, "{s}.exe", .{name});
            defer allocator.free(exe_name);
            if (try checkExecutableCandidate(allocator, dir, exe_name)) |found| return found;
        } else {
            if (try checkExecutableCandidate(allocator, dir, name)) |found| return found;
        }
    }

    return null;
}

fn checkExecutableCandidate(allocator: std.mem.Allocator, dir: []const u8, name: []const u8) !?[]u8 {
    const path = try std.fs.path.join(allocator, &.{ dir, name });
    defer allocator.free(path);

    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {
        error.FileNotFound, error.NotDir, error.AccessDenied => return null,
        else => return err,
    };
    file.close();

    return try allocator.dupe(u8, path);
}

fn initProject(allocator: std.mem.Allocator, dir_path: []const u8) !void {
    _ = allocator;
    var cwd = std.fs.cwd();
    if (dir_path.len > 0 and !std.mem.eql(u8, dir_path, ".")) {
        try cwd.makePath(dir_path);
    }

    var dir = try cwd.openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    try dir.makePath("src");
    try dir.makePath("out");

    try dir.writeFile(.{ .sub_path = "build.zig", .data = Template.build_zig });
    try dir.writeFile(.{ .sub_path = "build.zig.zon", .data = Template.build_zig_zon });
    try dir.writeFile(.{ .sub_path = "src/Contract.zig", .data = Template.contract_zig });
    try dir.writeFile(.{ .sub_path = "src/evm.zig", .data = Template.evm_zig });
}

fn buildAbi(allocator: std.mem.Allocator) !void {
    try ensureOutDir();

    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "compile");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "--abi");
    try argv.append(allocator, "out/Contract.abi.json");
    try argv.append(allocator, "-o");
    try argv.append(allocator, "out/Contract.yul");
    try argv.append(allocator, "src/Contract.zig");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);
}

fn buildBytecode(allocator: std.mem.Allocator) ![]u8 {
    try ensureOutDir();

    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "build");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "-o");
    try argv.append(allocator, "out/Contract.bin");
    try argv.append(allocator, "src/Contract.zig");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);
    return try readTrimmedFile(allocator, "out/Contract.bin");
}

fn runLocalTest(allocator: std.mem.Allocator) !void {
    var anvil_argv: std.ArrayList([]const u8) = .empty;
    defer anvil_argv.deinit(allocator);

    try anvil_argv.append(allocator, "anvil");

    var anvil_child = std.process.Child.init(anvil_argv.items, allocator);
    anvil_child.stderr_behavior = .Ignore;
    anvil_child.stdout_behavior = .Ignore;

    try anvil_child.spawn();
    defer {
        _ = anvil_child.kill() catch {};
    }

    std.Thread.sleep(500 * std.time.ns_per_ms);

    const bytecode = try buildBytecode(allocator);
    defer allocator.free(bytecode);

    const address = try deployWithCast(allocator, default_rpc_url, default_anvil_private_key, bytecode);
    defer allocator.free(address);

    const send_output = try castSend(allocator, default_rpc_url, default_anvil_private_key, address, "set(uint256)", &.{"7"});
    defer allocator.free(send_output);
    const result = try castCall(allocator, default_rpc_url, address, "get()(uint256)");
    defer allocator.free(result);
    const trimmed = std.mem.trim(u8, result, " \n\r\t");

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Deployed: {s}\n", .{address});
    try stdout.print("get() => {s}\n", .{trimmed});
    try stdout.flush();
}

fn runProfileTest(allocator: std.mem.Allocator) !void {
    var anvil_argv: std.ArrayList([]const u8) = .empty;
    defer anvil_argv.deinit(allocator);

    try anvil_argv.append(allocator, "anvil");

    var anvil_child = std.process.Child.init(anvil_argv.items, allocator);
    anvil_child.stderr_behavior = .Ignore;
    anvil_child.stdout_behavior = .Ignore;

    try anvil_child.spawn();
    defer {
        _ = anvil_child.kill() catch {};
    }

    std.Thread.sleep(500 * std.time.ns_per_ms);

    try ensureOutDir();

    const profile_json = try runZigToYulProfile(allocator, default_rpc_url);
    defer allocator.free(profile_json);

    const estimate_json = try runZigToYulEstimate(allocator);
    defer allocator.free(estimate_json);

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Profile written: out/profile.json\n", .{});
    try stdout.print("Estimate output:\n{s}\n", .{estimate_json});
    try stdout.flush();
}

fn runZigToYulProfile(allocator: std.mem.Allocator, rpc_url: []const u8) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "profile");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, "--call-data");
    try argv.append(allocator, "0x");
    try argv.append(allocator, "--runs");
    try argv.append(allocator, "1");
    try argv.append(allocator, "--profile-out");
    try argv.append(allocator, "out/profile.json");
    try argv.append(allocator, "src/Contract.zig");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);
    return try readTrimmedFile(allocator, "out/profile.json");
}

fn runZigToYulEstimate(allocator: std.mem.Allocator) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "estimate");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "--profile");
    try argv.append(allocator, "out/profile.json");
    try argv.append(allocator, "src/Contract.zig");

    return try runCommandCapture(allocator, argv.items);
}

const ProfileSettings = struct {
    rpc_url: []u8,
    chain_id: ?u64,
    private_key_env: []const u8,

    pub fn deinit(self: *ProfileSettings, allocator: std.mem.Allocator) void {
        allocator.free(self.rpc_url);
    }
};

fn deployRemote(allocator: std.mem.Allocator, rpc_url: []const u8, private_key_env: []const u8) !void {
    const private_key = try getEnvRequired(allocator, private_key_env);
    defer allocator.free(private_key);

    const bytecode = try buildBytecode(allocator);
    defer allocator.free(bytecode);

    const address = try deployWithCast(allocator, rpc_url, private_key, bytecode);
    defer allocator.free(address);

    try writeCallScript(allocator, rpc_url, address);

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Contract deployed: {s}\n", .{address});
    try stdout.print("Script written: out/call_contract.sh\n", .{});
    try stdout.flush();
}

fn deployWithCast(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    private_key: []const u8,
    bytecode: []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "send");
    try argv.append(allocator, "--create");
    try argv.append(allocator, bytecode);
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, "--private-key");
    try argv.append(allocator, private_key);
    try argv.append(allocator, "--json");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);

    const address = extractContractAddress(output) orelse {
        std.debug.print("cast send output:\n{s}\n", .{output});
        return error.DeployFailed;
    };
    return try allocator.dupe(u8, address);
}

fn castSend(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    private_key: []const u8,
    address: []const u8,
    signature: []const u8,
    args: []const []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "send");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, "--private-key");
    try argv.append(allocator, private_key);
    try argv.append(allocator, address);
    try argv.append(allocator, signature);
    for (args) |arg| {
        try argv.append(allocator, arg);
    }

    return try runCommandCapture(allocator, argv.items);
}

fn castCall(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    address: []const u8,
    signature: []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "call");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, address);
    try argv.append(allocator, signature);

    return try runCommandCapture(allocator, argv.items);
}

fn writeCallScript(allocator: std.mem.Allocator, rpc_url: []const u8, address: []const u8) !void {
    try ensureOutDir();

    const script = try std.fmt.allocPrint(
        allocator,
        "#!/usr/bin/env bash\n" ++
            "set -euo pipefail\n\n" ++
            "RPC_URL=\"{s}\"\n" ++
            "PRIVATE_KEY=\"${{PRIVATE_KEY:?set PRIVATE_KEY}}\"\n" ++
            "ADDR=\"{s}\"\n\n" ++
            "cast send --rpc-url \"$RPC_URL\" --private-key \"$PRIVATE_KEY\" \"$ADDR\" \"set(uint256)\" 7\n" ++
            "cast call --rpc-url \"$RPC_URL\" \"$ADDR\" \"get()(uint256)\"\n",
        .{ rpc_url, address },
    );
    defer allocator.free(script);

    const file = try std.fs.cwd().createFile("out/call_contract.sh", .{ .mode = 0o755 });
    defer file.close();
    try file.writeAll(script);
}

fn ensureOutDir() !void {
    try std.fs.cwd().makePath("out");
}

fn getEnvRequired(allocator: std.mem.Allocator, key: []const u8) ![]u8 {
    return std.process.getEnvVarOwned(allocator, key) catch |err| switch (err) {
        error.EnvironmentVariableNotFound => {
            std.debug.print("Missing required environment variable: {s}\n", .{key});
            return error.MissingEnv;
        },
        else => return err,
    };
}

fn resolveRpcSettings(
    allocator: std.mem.Allocator,
    profile_name: ?[]const u8,
    rpc_url: ?[]const u8,
) !ProfileSettings {
    if (profile_name != null and rpc_url != null) {
        std.debug.print("Error: --profile and --rpc-url are mutually exclusive\n", .{});
        return error.InvalidArgs;
    }

    if (profile_name) |name| {
        const profile = try loadProfile(allocator, name) orelse {
            std.debug.print("Profile not found: {s}\n", .{name});
            return error.ProfileNotFound;
        };
        return profile;
    }

    const url = rpc_url orelse default_rpc_url;
    return .{
        .rpc_url = try allocator.dupe(u8, url),
        .chain_id = null,
        .private_key_env = default_private_key_env,
    };
}

fn loadProfile(allocator: std.mem.Allocator, name: []const u8) !?ProfileSettings {
    const file = std.fs.cwd().openFile("profiles.json", .{}) catch |err| switch (err) {
        error.FileNotFound => return null,
        else => return err,
    };
    defer file.close();

    const json_bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(json_bytes);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_bytes, .{});
    defer parsed.deinit();

    const root = parsed.value;
    const profiles_value = try selectProfilesObject(root);
    if (profiles_value.object.get(name)) |entry| {
        if (entry != .object) return error.InvalidProfile;
        return try parseProfileObject(allocator, entry.object);
    }

    return null;
}

fn selectProfilesObject(value: std.json.Value) !std.json.Value {
    if (value != .object) return error.InvalidProfile;
    if (value.object.get("profiles")) |profiles| {
        if (profiles != .object) return error.InvalidProfile;
        return profiles;
    }
    return value;
}

fn parseProfileObject(allocator: std.mem.Allocator, obj: std.json.ObjectMap) !ProfileSettings {
    const rpc_value = obj.get("rpc_url") orelse return error.InvalidProfile;
    if (rpc_value != .string) return error.InvalidProfile;
    const rpc_url = try allocator.dupe(u8, rpc_value.string);

    var chain_id: ?u64 = null;
    if (obj.get("chain_id")) |value| {
        switch (value) {
            .integer => |v| {
                if (v < 0) return error.InvalidProfile;
                chain_id = @intCast(v);
            },
            .string => |s| {
                chain_id = try std.fmt.parseInt(u64, s, 10);
            },
            else => return error.InvalidProfile,
        }
    }

    var private_key_env: []const u8 = default_private_key_env;
    if (obj.get("private_key_env")) |value| {
        if (value != .string) return error.InvalidProfile;
        private_key_env = value.string;
    }

    return .{
        .rpc_url = rpc_url,
        .chain_id = chain_id,
        .private_key_env = private_key_env,
    };
}

fn signatureFromAbi(allocator: std.mem.Allocator, path: []const u8, func_name: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const json_bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(json_bytes);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_bytes, .{});
    defer parsed.deinit();

    if (parsed.value != .array) return error.InvalidAbi;
    for (parsed.value.array.items) |entry| {
        if (entry != .object) continue;
        const obj = entry.object;
        const type_field = obj.get("type") orelse continue;
        if (type_field != .string) continue;
        if (!std.mem.eql(u8, type_field.string, "function")) continue;
        const name_field = obj.get("name") orelse continue;
        if (name_field != .string) continue;
        if (!std.mem.eql(u8, name_field.string, func_name)) continue;

        var args_list: std.ArrayList([]const u8) = .empty;
        defer args_list.deinit(allocator);
        if (obj.get("inputs")) |inputs| {
            if (inputs == .array) {
                for (inputs.array.items) |input| {
                    if (input != .object) continue;
                    if (input.object.get("type")) |type_value| {
                        if (type_value == .string) {
                            try args_list.append(allocator, type_value.string);
                        }
                    }
                }
            }
        }

        return try buildSignature(allocator, func_name, args_list.items);
    }

    return error.FunctionNotFound;
}

fn buildSignature(allocator: std.mem.Allocator, name: []const u8, types: []const []const u8) ![]u8 {
    var buffer: std.ArrayList(u8) = .empty;
    defer buffer.deinit(allocator);

    try buffer.appendSlice(allocator, name);
    try buffer.append(allocator, '(');
    for (types, 0..) |t, idx| {
        if (idx > 0) try buffer.append(allocator, ',');
        try buffer.appendSlice(allocator, t);
    }
    try buffer.append(allocator, ')');
    return try buffer.toOwnedSlice(allocator);
}

fn castCallArgs(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    address: []const u8,
    signature: []const u8,
    args: []const []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "call");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, address);
    try argv.append(allocator, signature);
    for (args) |arg| {
        try argv.append(allocator, arg);
    }

    return try runCommandCapture(allocator, argv.items);
}

fn runCommandCapture(allocator: std.mem.Allocator, argv: []const []const u8) ![]u8 {
    var child = std.process.Child.init(argv, allocator);
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;

    try child.spawn();

    var stdout_buf: [64 * 1024]u8 = undefined;
    var stderr_buf: [64 * 1024]u8 = undefined;
    const stdout_len = child.stdout.?.readAll(&stdout_buf) catch 0;
    const stderr_len = child.stderr.?.readAll(&stderr_buf) catch 0;

    const term = try child.wait();
    if (term.Exited != 0) {
        const stderr = stderr_buf[0..stderr_len];
        const stdout = stdout_buf[0..stdout_len];
        std.debug.print("Command failed: {s}\n{s}\n{s}\n", .{ argv[0], stdout, stderr });
        return error.CommandFailed;
    }

    return try allocator.dupe(u8, stdout_buf[0..stdout_len]);
}

fn readTrimmedFile(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    const trimmed = std.mem.trim(u8, data, " \n\r\t");
    return try allocator.dupe(u8, trimmed);
}

fn extractContractAddress(output: []const u8) ?[]const u8 {
    const key = "\"contractAddress\":\"";
    const start = std.mem.indexOf(u8, output, key) orelse return null;
    const addr_start = start + key.len;
    const addr_end = std.mem.indexOfPos(u8, output, addr_start, "\"") orelse return null;
    return output[addr_start..addr_end];
}
