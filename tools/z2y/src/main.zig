//! Source: z2y tool (no Rust reference)
const std = @import("std");

const Template = struct {
    const build_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) void {
        \\    const target = b.standardTargetOptions(.{});
        \\    const optimize = b.standardOptimizeOption(.{});
        \\
        \\    _ = target;
        \\    _ = optimize;
        \\
        \\    const compile_step = b.addSystemCommand(&.{
        \\        "zig-to-yul",
        \\        "compile",
        \\        "--project",
        \\        ".",
        \\        "--abi",
        \\        "contracts/Contract.abi.json",
        \\        "-o",
        \\        "contracts/Contract.yul",
        \\        "src/Contract.zig",
        \\    });
        \\
        \\    const solc_step = b.addSystemCommand(&.{
        \\        "solc",
        \\        "--strict-assembly",
        \\        "--bin",
        \\        "contracts/Contract.yul",
        \\        "-o",
        \\        "contracts",
        \\    });
        \\    solc_step.step.dependOn(&compile_step.step);
        \\
        \\    const contract_step = b.step("contract", "Build contract bytecode");
        \\    contract_step.dependOn(&solc_step.step);
        \\    b.getInstallStep().dependOn(&solc_step.step);
        \\}
    ;

    const build_zig_zon =
        \\// Generated by z2y. Use `zig fetch --save` to add dependencies.
        \\// See: https://ziglang.org/learn/build-system/#package-management
        \\.{
        \\    .name = "contract",
        \\    .version = "0.1.0",
        \\    .dependencies = .{},
        \\}
    ;

    const contract_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const evm = @import("evm");
        \\
        \\pub const Contract = struct {
        \\    value: u256,
        \\
        \\    pub fn set(self: *Contract, next: u256) void {
        \\        self.value = next;
        \\    }
        \\
        \\    pub fn get(self: *Contract) u256 {
        \\        return self.value;
        \\    }
        \\
        \\    pub fn add(self: *Contract, delta: u256) u256 {
        \\        self.value = self.value + delta;
        \\        return self.value;
        \\    }
        \\};
    ;
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        try printUsage();
        return;
    }

    const command = args[1];
    if (std.mem.eql(u8, command, "init")) {
        const target_dir = if (args.len >= 3) args[2] else ".";
        if (args.len > 3) {
            try printUsage();
            return;
        }
        try initProject(allocator, target_dir);
        return;
    }

    try printUsage();
}

fn printUsage() !void {
    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Usage: z2y init [dir]\n", .{});
    try stdout.flush();
}

fn initProject(allocator: std.mem.Allocator, dir_path: []const u8) !void {
    var cwd = std.fs.cwd();
    if (dir_path.len > 0 and !std.mem.eql(u8, dir_path, ".")) {
        try cwd.makePath(dir_path);
    }

    var dir = try cwd.openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    try dir.makePath("src");
    try dir.makePath("contracts");

    try dir.writeFile(.{ .sub_path = "build.zig", .data = Template.build_zig });
    try dir.writeFile(.{ .sub_path = "build.zig.zon", .data = Template.build_zig_zon });
    try dir.writeFile(.{ .sub_path = "src/Contract.zig", .data = Template.contract_zig });

    try addDependency(allocator, dir);
}

fn addDependency(allocator: std.mem.Allocator, dir: std.fs.Dir) !void {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig");
    try argv.append(allocator, "fetch");
    try argv.append(allocator, "--save");
    try argv.append(allocator, "git@github.com:DaviRain-Su/zig-to-yul.git");

    var child = std.process.Child.init(argv.items, allocator);
    child.cwd_dir = dir;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;

    try child.spawn();

    var stdout_buf: [32 * 1024]u8 = undefined;
    var stderr_buf: [32 * 1024]u8 = undefined;
    const stdout_len = child.stdout.?.readAll(&stdout_buf) catch 0;
    const stderr_len = child.stderr.?.readAll(&stderr_buf) catch 0;

    const term = try child.wait();
    if (term.Exited != 0) {
        const stderr = stderr_buf[0..stderr_len];
        const stdout = stdout_buf[0..stdout_len];
        std.debug.print("zig fetch --save failed\n{s}\n{s}\n", .{ stdout, stderr });
        return error.DependencyFetchFailed;
    }
}
