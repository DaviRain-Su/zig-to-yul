//! Source: z2y tool (no Rust reference)
const std = @import("std");

const Template = struct {
    const build_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) void {
        \\    const target = b.standardTargetOptions(.{});
        \\    const optimize = b.standardOptimizeOption(.{});
        \\
        \\    const zig_to_yul = b.dependency("zig_to_yul", .{
        \\        .target = target,
        \\        .optimize = optimize,
        \\    });
        \\
        \\    const evm_mod = b.createModule(.{
        \\        .root_source_file = b.path("src/evm.zig"),
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .imports = &.{
        \\            .{ .name = "zig_to_yul", .module = zig_to_yul.module("zig_to_yul") },
        \\        },
        \\    });
        \\
        \\    // Provide root_source_file and module imports for --project.
        \\    const contract_mod = b.createModule(.{
        \\        .root_source_file = b.path("src/Contract.zig"),
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .imports = &.{
        \\            .{ .name = "evm", .module = evm_mod },
        \\        },
        \\    });
        \\    _ = contract_mod;
        \\
        \\    const build_step = b.addSystemCommand(&.{
        \\        "zig_to_yul",
        \\        "build",
        \\        "--project",
        \\        ".",
        \\        "--abi",
        \\        "out/Contract.abi.json",
        \\        "-o",
        \\        "out/Contract.bin",
        \\        "src/Contract.zig",
        \\    });
        \\
        \\    const contract_step = b.step("contract", "Build contract bytecode");
        \\    contract_step.dependOn(&build_step.step);
        \\    b.getInstallStep().dependOn(&build_step.step);
        \\}
    ;

    const build_zig_zon =
        \\// Generated by z2y. Use `zig fetch --save` to add dependencies.
        \\// See: https://ziglang.org/learn/build-system/#package-management
        \\.{
        \\    .name = .contract,
        \\    .version = "0.1.0",
        \\    .fingerprint = 0xe98f285936ce0bb3,
        \\    .minimum_zig_version = "0.15.2",
        \\    .paths = .{"."},
        \\    .dependencies = .{
        \\        .zig_to_yul = .{
        \\            .url = "https://github.com/DaviRain-Su/zig-to-yul/archive/refs/tags/v0.1.0.tar.gz",
        \\            .hash = "zig_to_yul-0.1.0-Gzz9gG-JCwAJ83VLKjBL6GhWOsre03bs3Z_BRV1LrSLl",
        \\        },
        \\    },
        \\}
    ;

    const evm_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const sdk = @import("zig_to_yul").evm;
        \\
        \\pub const types = sdk.types;
        \\pub const storage = sdk.storage;
        \\pub const event_decode = sdk.event_decode;
        \\pub const event_encode = sdk.event_encode;
        \\pub const event = sdk.event;
        \\pub const builtins = sdk.builtins_stub;
        \\pub const builtins_spec = sdk.builtins;
        \\pub const abi = sdk.abi;
        \\pub const precompile = sdk.precompile;
        \\pub const rpc = sdk.rpc;
        \\pub const contract = sdk.contract;
        \\pub const U256 = sdk.U256;
        \\pub const Address = sdk.Address;
        \\pub const EvmType = sdk.EvmType;
    ;

    const contract_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const evm = @import("evm.zig");
        \\
        \\pub const Contract = struct {
        \\    value: evm.U256,
        \\
        \\    pub fn set(self: *Contract, next: evm.U256) void {
        \\        self.value = next;
        \\    }
        \\
        \\    pub fn get(self: *Contract) evm.U256 {
        \\        return self.value;
        \\    }
        \\
        \\    pub fn add(self: *Contract, delta: evm.U256) evm.U256 {
        \\        self.value = self.value + delta;
        \\        return self.value;
        \\    }
        \\};
    ;
};

const default_rpc_url = "http://localhost:8545";
const default_anvil_private_key = "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";
const default_private_key_env = "PRIVATE_KEY";

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        try printUsage();
        return;
    }

    const command = args[1];
    if (std.mem.eql(u8, command, "init")) {
        const target_dir = if (args.len >= 3) args[2] else ".";
        if (args.len > 3) {
            try printUsage();
            return;
        }
        try initProject(allocator, target_dir);
        return;
    }

    if (std.mem.eql(u8, command, "install")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try installTools(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "info")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try printToolInfo(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "build-abi")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try buildAbi(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "test")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try runLocalTest(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "deploy")) {
        var rpc_url: ?[]const u8 = null;
        var profile_name: ?[]const u8 = null;
        var i: usize = 2;
        while (i < args.len) : (i += 1) {
            const arg = args[i];
            if (std.mem.eql(u8, arg, "--rpc-url")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                rpc_url = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--profile")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                profile_name = args[i];
                continue;
            }
            try printUsage();
            return;
        }
        var resolved = try resolveRpcSettings(allocator, profile_name, rpc_url);
        defer resolved.deinit(allocator);
        try deployRemote(allocator, resolved.rpc_url, resolved.private_key_env);
        return;
    }

    if (std.mem.eql(u8, command, "call")) {
        var rpc_url: ?[]const u8 = null;
        var profile_name: ?[]const u8 = null;
        var address: ?[]const u8 = null;
        var signature: ?[]const u8 = null;
        var abi_path: ?[]const u8 = null;
        var func_name: ?[]const u8 = null;
        var args_start: ?usize = null;

        var i: usize = 2;
        while (i < args.len) : (i += 1) {
            const arg = args[i];
            if (std.mem.eql(u8, arg, "--rpc-url")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                rpc_url = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--profile")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                profile_name = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--address")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                address = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--sig")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                signature = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--abi")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                abi_path = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--func")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                func_name = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--args")) {
                args_start = i + 1;
                break;
            }
            try printUsage();
            return;
        }

        if (address == null) {
            try printUsage();
            return;
        }

        var resolved = try resolveRpcSettings(allocator, profile_name, rpc_url);
        defer resolved.deinit(allocator);

        var owned_signature: ?[]u8 = null;
        if (signature == null) {
            if (abi_path == null or func_name == null) {
                try printUsage();
                return;
            }
            owned_signature = try signatureFromAbi(allocator, abi_path.?, func_name.?);
            signature = owned_signature;
        }
        defer if (owned_signature) |sig| allocator.free(sig);

        const call_args = if (args_start) |start| args[start..] else &.{};
        const output = try castCallArgs(allocator, resolved.rpc_url, address.?, signature.?, call_args);
        defer allocator.free(output);

        var stdout_buffer: [1024]u8 = undefined;
        var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
        const stdout: *std.Io.Writer = &stdout_writer.interface;
        try stdout.print("{s}\n", .{std.mem.trim(u8, output, " \n\r\t")});
        try stdout.flush();
        return;
    }

    if (std.mem.eql(u8, command, "build")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        const output = try buildBytecode(allocator);
        defer allocator.free(output);

        var stdout_buffer: [1024]u8 = undefined;
        var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
        const stdout: *std.Io.Writer = &stdout_writer.interface;
        try stdout.print("Bytecode written: out/Contract.bin\n", .{});
        try stdout.flush();
        return;
    }

    if (std.mem.eql(u8, command, "profile-test")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try runProfileTest(allocator);
        return;
    }

    if (std.mem.eql(u8, command, "abi-gen")) {
        var abi_path: []const u8 = "out/Contract.abi.json";
        var out_path: []const u8 = "src/ContractAbi.zig";
        var module_name: []const u8 = "ExternalContract";
        var i: usize = 2;
        while (i < args.len) : (i += 1) {
            const arg = args[i];
            if (std.mem.eql(u8, arg, "--abi")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                abi_path = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--out")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                out_path = args[i];
                continue;
            }
            if (std.mem.eql(u8, arg, "--name")) {
                i += 1;
                if (i >= args.len) {
                    try printUsage();
                    return;
                }
                module_name = args[i];
                continue;
            }
            try printUsage();
            return;
        }

        try generateAbiWrapper(allocator, abi_path, out_path, module_name);
        return;
    }

    try printUsage();
}

fn printUsage() !void {
    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print(
        "Usage:\n" ++
            "  z2y init [dir]\n" ++
            "  z2y install\n" ++
            "  z2y info\n" ++
            "  z2y build\n" ++
            "  z2y build-abi\n" ++
            "  z2y test\n" ++
            "  z2y profile-test\n" ++
            "  z2y abi-gen [--abi <file>] [--out <file>] [--name <Module>]\n" ++
            "  z2y deploy [--rpc-url <url> | --profile <name>]\n" ++
            "  z2y call --address <addr> (--sig <signature> | --abi <file> --func <name>) [--args ...] [--rpc-url <url> | --profile <name>]\n",
        .{},
    );

    try stdout.flush();
}

fn printInstallInstructions() !void {
    const builtin = @import("builtin");
    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;

    try stdout.print("Required tools:\n", .{});
    try stdout.print("- Zig 0.15.2\n", .{});
    try stdout.print("- solc (Solidity compiler)\n", .{});
    try stdout.print("- zig-to-yul binary in PATH\n", .{});
    try stdout.print("- Foundry (anvil/forge/cast)\n", .{});
    try stdout.print("- profiles.json (optional, for named RPC profiles)\n\n", .{});

    switch (builtin.os.tag) {
        .macos => {
            try stdout.print("Install Zig (macOS):\n  brew install zig\n", .{});
        },
        .linux => {
            try stdout.print("Install Zig (Linux):\n  https://ziglang.org/download/\n", .{});
        },
        .windows => {
            try stdout.print("Install Zig (Windows):\n  choco install zig\n", .{});
        },
        else => {
            try stdout.print("Install Zig:\n  https://ziglang.org/download/\n", .{});
        },
    }

    try stdout.print("\nInstall solc:\n  npm install -g solc\n", .{});
    try stdout.print("\nInstall Foundry (anvil/forge):\n  curl -L https://foundry.paradigm.xyz | bash\n  foundryup\n", .{});
    try stdout.print("\nInstall zig-to-yul (needed for compilation):\n  z2y install\n", .{});
    try stdout.flush();
}

fn installTools(allocator: std.mem.Allocator) !void {
    const builtin = @import("builtin");
    if (builtin.os.tag != .linux and builtin.os.tag != .macos) {
        try printInstallInstructions();
        return;
    }

    const home = std.process.getEnvVarOwned(allocator, "HOME") catch return error.InvalidEnvironment;
    defer allocator.free(home);

    const bin_dir = try std.fs.path.join(allocator, &.{ home, ".local", "bin" });
    defer allocator.free(bin_dir);

    try runCommand(allocator, &.{ "mkdir", "-p", bin_dir });

    if (try findExecutablePath(allocator, "zig")) |path| {
        allocator.free(path);
    } else {
        var stdout_buffer: [2048]u8 = undefined;
        var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
        const stdout: *std.Io.Writer = &stdout_writer.interface;
        try stdout.print("Zig not found. Please install Zig 0.15.2 first.\n", .{});
        try stdout.flush();
        return error.MissingZig;
    }

    try installReleaseBinaries(allocator, bin_dir);

    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Install complete. Ensure {s} is on PATH.\n", .{bin_dir});
    try stdout.flush();
}

fn installReleaseBinaries(allocator: std.mem.Allocator, bin_dir: []const u8) !void {
    const builtin = @import("builtin");
    const os_tag = builtin.os.tag;
    const os_label = if (os_tag == .linux) "ubuntu-latest" else "macos-latest";

    const archive_name = try std.fmt.allocPrint(allocator, "zig-to-yul-{s}.tar.gz", .{os_label});
    defer allocator.free(archive_name);
    const url = try std.fmt.allocPrint(allocator, "https://github.com/DaviRain-Su/zig-to-yul/releases/download/v0.1.0/{s}", .{archive_name});
    defer allocator.free(url);

    const tmp_dir = try std.fs.path.join(allocator, &.{ "/tmp", "z2y" });
    defer allocator.free(tmp_dir);
    try runCommand(allocator, &.{ "mkdir", "-p", tmp_dir });

    const archive_path = try std.fs.path.join(allocator, &.{ tmp_dir, archive_name });
    defer allocator.free(archive_path);
    try runCommand(allocator, &.{ "curl", "-L", "-o", archive_path, url });

    const extract_dir = try std.fs.path.join(allocator, &.{ tmp_dir, "release" });
    defer allocator.free(extract_dir);
    try runCommand(allocator, &.{ "rm", "-rf", extract_dir });
    try runCommand(allocator, &.{ "mkdir", "-p", extract_dir });
    try runCommand(allocator, &.{ "tar", "-xzf", archive_path, "-C", extract_dir });

    const zig_to_yul_bin = try std.fs.path.join(allocator, &.{ extract_dir, "zig_to_yul" });
    defer allocator.free(zig_to_yul_bin);
    const z2y_bin = try std.fs.path.join(allocator, &.{ extract_dir, "z2y" });
    defer allocator.free(z2y_bin);

    const zig_to_yul_target = try std.fs.path.join(allocator, &.{ bin_dir, "zig_to_yul" });
    defer allocator.free(zig_to_yul_target);

    try runCommand(allocator, &.{ "cp", zig_to_yul_bin, zig_to_yul_target });
}

fn runCommand(allocator: std.mem.Allocator, argv: []const []const u8) !void {
    const output = try runCommandCapture(allocator, argv);
    allocator.free(output);
}

fn printToolInfo(allocator: std.mem.Allocator) !void {
    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;

    try printToolStatus(allocator, stdout, "zig");
    try printToolStatus(allocator, stdout, "z2y");
    try printToolStatus(allocator, stdout, "zig-to-yul");
    try printToolStatus(allocator, stdout, "solc");
    try printToolStatus(allocator, stdout, "anvil");
    try printToolStatus(allocator, stdout, "forge");
    try printToolStatus(allocator, stdout, "cast");
    try stdout.flush();
}

fn printToolStatus(allocator: std.mem.Allocator, stdout: *std.Io.Writer, name: []const u8) !void {
    const path = try findExecutablePath(allocator, name);
    defer if (path) |p| allocator.free(p);

    if (path) |p| {
        try stdout.print("{s}: found ({s})\n", .{ name, p });
    } else {
        try stdout.print("{s}: missing\n", .{name});
    }
}

fn findExecutablePath(allocator: std.mem.Allocator, name: []const u8) !?[]u8 {
    const builtin = @import("builtin");
    const path_value = std.process.getEnvVarOwned(allocator, "PATH") catch |err| switch (err) {
        error.EnvironmentVariableNotFound => return null,
        else => return err,
    };
    defer allocator.free(path_value);

    var it = std.mem.splitScalar(u8, path_value, std.fs.path.delimiter);
    while (it.next()) |dir| {
        if (dir.len == 0) continue;

        if (builtin.os.tag == .windows) {
            if (try checkExecutableCandidate(allocator, dir, name)) |found| return found;
            const exe_name = try std.fmt.allocPrint(allocator, "{s}.exe", .{name});
            defer allocator.free(exe_name);
            if (try checkExecutableCandidate(allocator, dir, exe_name)) |found| return found;
        } else {
            if (try checkExecutableCandidate(allocator, dir, name)) |found| return found;
        }
    }

    return null;
}

fn checkExecutableCandidate(allocator: std.mem.Allocator, dir: []const u8, name: []const u8) !?[]u8 {
    const path = try std.fs.path.join(allocator, &.{ dir, name });
    defer allocator.free(path);

    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {
        error.FileNotFound, error.NotDir, error.AccessDenied => return null,
        else => return err,
    };
    file.close();

    return try allocator.dupe(u8, path);
}

fn initProject(allocator: std.mem.Allocator, dir_path: []const u8) !void {
    _ = allocator;
    var cwd = std.fs.cwd();
    if (dir_path.len > 0 and !std.mem.eql(u8, dir_path, ".")) {
        try cwd.makePath(dir_path);
    }

    var dir = try cwd.openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    try dir.makePath("src");
    try dir.makePath("out");

    try dir.writeFile(.{ .sub_path = "build.zig", .data = Template.build_zig });
    try dir.writeFile(.{ .sub_path = "build.zig.zon", .data = Template.build_zig_zon });
    try dir.writeFile(.{ .sub_path = "src/Contract.zig", .data = Template.contract_zig });
    try dir.writeFile(.{ .sub_path = "src/evm.zig", .data = Template.evm_zig });
}

fn buildAbi(allocator: std.mem.Allocator) !void {
    try ensureOutDir();

    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "compile");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "--abi");
    try argv.append(allocator, "out/Contract.abi.json");
    try argv.append(allocator, "-o");
    try argv.append(allocator, "out/Contract.yul");
    try argv.append(allocator, "src/Contract.zig");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);
}

fn buildBytecode(allocator: std.mem.Allocator) ![]u8 {
    try ensureOutDir();

    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "build");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "-o");
    try argv.append(allocator, "out/Contract.bin");
    try argv.append(allocator, "src/Contract.zig");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);
    return try readTrimmedFile(allocator, "out/Contract.bin");
}

fn runLocalTest(allocator: std.mem.Allocator) !void {
    var anvil_argv: std.ArrayList([]const u8) = .empty;
    defer anvil_argv.deinit(allocator);

    try anvil_argv.append(allocator, "anvil");

    var anvil_child = std.process.Child.init(anvil_argv.items, allocator);
    anvil_child.stderr_behavior = .Ignore;
    anvil_child.stdout_behavior = .Ignore;

    try anvil_child.spawn();
    defer {
        _ = anvil_child.kill() catch {};
    }

    std.Thread.sleep(500 * std.time.ns_per_ms);

    const bytecode = try buildBytecode(allocator);
    defer allocator.free(bytecode);

    const address = try deployWithCast(allocator, default_rpc_url, default_anvil_private_key, bytecode);
    defer allocator.free(address);

    const send_output = try castSend(allocator, default_rpc_url, default_anvil_private_key, address, "set(uint256)", &.{"7"});
    defer allocator.free(send_output);
    const result = try castCall(allocator, default_rpc_url, address, "get()(uint256)");
    defer allocator.free(result);
    const trimmed = std.mem.trim(u8, result, " \n\r\t");

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Deployed: {s}\n", .{address});
    try stdout.print("get() => {s}\n", .{trimmed});
    try stdout.flush();
}

fn runProfileTest(allocator: std.mem.Allocator) !void {
    var anvil_argv: std.ArrayList([]const u8) = .empty;
    defer anvil_argv.deinit(allocator);

    try anvil_argv.append(allocator, "anvil");

    var anvil_child = std.process.Child.init(anvil_argv.items, allocator);
    anvil_child.stderr_behavior = .Ignore;
    anvil_child.stdout_behavior = .Ignore;

    try anvil_child.spawn();
    defer {
        _ = anvil_child.kill() catch {};
    }

    std.Thread.sleep(500 * std.time.ns_per_ms);

    try ensureOutDir();

    const profile_json = try runZigToYulProfile(allocator, default_rpc_url);
    defer allocator.free(profile_json);

    const estimate_json = try runZigToYulEstimate(allocator);
    defer allocator.free(estimate_json);

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Profile written: out/profile.json\n", .{});
    try stdout.print("Estimate output:\n{s}\n", .{estimate_json});
    try stdout.flush();
}

fn runZigToYulProfile(allocator: std.mem.Allocator, rpc_url: []const u8) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "profile");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, "--call-data");
    try argv.append(allocator, "0x");
    try argv.append(allocator, "--runs");
    try argv.append(allocator, "1");
    try argv.append(allocator, "--profile-out");
    try argv.append(allocator, "out/profile.json");
    try argv.append(allocator, "src/Contract.zig");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);
    return try readTrimmedFile(allocator, "out/profile.json");
}

fn runZigToYulEstimate(allocator: std.mem.Allocator) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig-to-yul");
    try argv.append(allocator, "estimate");
    try argv.append(allocator, "--project");
    try argv.append(allocator, ".");
    try argv.append(allocator, "--profile");
    try argv.append(allocator, "out/profile.json");
    try argv.append(allocator, "src/Contract.zig");

    return try runCommandCapture(allocator, argv.items);
}

const ProfileSettings = struct {
    rpc_url: []u8,
    chain_id: ?u64,
    private_key_env: []const u8,

    pub fn deinit(self: *ProfileSettings, allocator: std.mem.Allocator) void {
        allocator.free(self.rpc_url);
    }
};

fn deployRemote(allocator: std.mem.Allocator, rpc_url: []const u8, private_key_env: []const u8) !void {
    const private_key = try getEnvRequired(allocator, private_key_env);
    defer allocator.free(private_key);

    const bytecode = try buildBytecode(allocator);
    defer allocator.free(bytecode);

    const address = try deployWithCast(allocator, rpc_url, private_key, bytecode);
    defer allocator.free(address);

    try writeCallScript(allocator, rpc_url, address);

    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print("Contract deployed: {s}\n", .{address});
    try stdout.print("Script written: out/call_contract.sh\n", .{});
    try stdout.flush();
}

fn deployWithCast(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    private_key: []const u8,
    bytecode: []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "send");
    try argv.append(allocator, "--create");
    try argv.append(allocator, bytecode);
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, "--private-key");
    try argv.append(allocator, private_key);
    try argv.append(allocator, "--json");

    const output = try runCommandCapture(allocator, argv.items);
    defer allocator.free(output);

    const address = extractContractAddress(output) orelse {
        std.debug.print("cast send output:\n{s}\n", .{output});
        return error.DeployFailed;
    };
    return try allocator.dupe(u8, address);
}

fn castSend(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    private_key: []const u8,
    address: []const u8,
    signature: []const u8,
    args: []const []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "send");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, "--private-key");
    try argv.append(allocator, private_key);
    try argv.append(allocator, address);
    try argv.append(allocator, signature);
    for (args) |arg| {
        try argv.append(allocator, arg);
    }

    return try runCommandCapture(allocator, argv.items);
}

fn castCall(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    address: []const u8,
    signature: []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "call");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, address);
    try argv.append(allocator, signature);

    return try runCommandCapture(allocator, argv.items);
}

fn writeCallScript(allocator: std.mem.Allocator, rpc_url: []const u8, address: []const u8) !void {
    try ensureOutDir();

    const script = try std.fmt.allocPrint(
        allocator,
        "#!/usr/bin/env bash\n" ++
            "set -euo pipefail\n\n" ++
            "RPC_URL=\"{s}\"\n" ++
            "PRIVATE_KEY=\"${{PRIVATE_KEY:?set PRIVATE_KEY}}\"\n" ++
            "ADDR=\"{s}\"\n\n" ++
            "cast send --rpc-url \"$RPC_URL\" --private-key \"$PRIVATE_KEY\" \"$ADDR\" \"set(uint256)\" 7\n" ++
            "cast call --rpc-url \"$RPC_URL\" \"$ADDR\" \"get()(uint256)\"\n",
        .{ rpc_url, address },
    );
    defer allocator.free(script);

    const file = try std.fs.cwd().createFile("out/call_contract.sh", .{ .mode = 0o755 });
    defer file.close();
    try file.writeAll(script);
}

fn ensureOutDir() !void {
    try std.fs.cwd().makePath("out");
}

fn getEnvRequired(allocator: std.mem.Allocator, key: []const u8) ![]u8 {
    return std.process.getEnvVarOwned(allocator, key) catch |err| switch (err) {
        error.EnvironmentVariableNotFound => {
            std.debug.print("Missing required environment variable: {s}\n", .{key});
            return error.MissingEnv;
        },
        else => return err,
    };
}

fn resolveRpcSettings(
    allocator: std.mem.Allocator,
    profile_name: ?[]const u8,
    rpc_url: ?[]const u8,
) !ProfileSettings {
    if (profile_name != null and rpc_url != null) {
        std.debug.print("Error: --profile and --rpc-url are mutually exclusive\n", .{});
        return error.InvalidArgs;
    }

    if (profile_name) |name| {
        const profile = try loadProfile(allocator, name) orelse {
            std.debug.print("Profile not found: {s}\n", .{name});
            return error.ProfileNotFound;
        };
        return profile;
    }

    const url = rpc_url orelse default_rpc_url;
    return .{
        .rpc_url = try allocator.dupe(u8, url),
        .chain_id = null,
        .private_key_env = default_private_key_env,
    };
}

fn loadProfile(allocator: std.mem.Allocator, name: []const u8) !?ProfileSettings {
    const file = std.fs.cwd().openFile("profiles.json", .{}) catch |err| switch (err) {
        error.FileNotFound => return null,
        else => return err,
    };
    defer file.close();

    const json_bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(json_bytes);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_bytes, .{});
    defer parsed.deinit();

    const root = parsed.value;
    const profiles_value = try selectProfilesObject(root);
    if (profiles_value.object.get(name)) |entry| {
        if (entry != .object) return error.InvalidProfile;
        return try parseProfileObject(allocator, entry.object);
    }

    return null;
}

fn selectProfilesObject(value: std.json.Value) !std.json.Value {
    if (value != .object) return error.InvalidProfile;
    if (value.object.get("profiles")) |profiles| {
        if (profiles != .object) return error.InvalidProfile;
        return profiles;
    }
    return value;
}

fn parseProfileObject(allocator: std.mem.Allocator, obj: std.json.ObjectMap) !ProfileSettings {
    const rpc_value = obj.get("rpc_url") orelse return error.InvalidProfile;
    if (rpc_value != .string) return error.InvalidProfile;
    const rpc_url = try allocator.dupe(u8, rpc_value.string);

    var chain_id: ?u64 = null;
    if (obj.get("chain_id")) |value| {
        switch (value) {
            .integer => |v| {
                if (v < 0) return error.InvalidProfile;
                chain_id = @intCast(v);
            },
            .string => |s| {
                chain_id = try std.fmt.parseInt(u64, s, 10);
            },
            else => return error.InvalidProfile,
        }
    }

    var private_key_env: []const u8 = default_private_key_env;
    if (obj.get("private_key_env")) |value| {
        if (value != .string) return error.InvalidProfile;
        private_key_env = value.string;
    }

    return .{
        .rpc_url = rpc_url,
        .chain_id = chain_id,
        .private_key_env = private_key_env,
    };
}

fn signatureFromAbi(allocator: std.mem.Allocator, path: []const u8, func_name: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const json_bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(json_bytes);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_bytes, .{});
    defer parsed.deinit();

    if (parsed.value != .array) return error.InvalidAbi;
    for (parsed.value.array.items) |entry| {
        if (entry != .object) continue;
        const obj = entry.object;
        const type_field = obj.get("type") orelse continue;
        if (type_field != .string) continue;
        if (!std.mem.eql(u8, type_field.string, "function")) continue;
        const name_field = obj.get("name") orelse continue;
        if (name_field != .string) continue;
        if (!std.mem.eql(u8, name_field.string, func_name)) continue;

        var args_list: std.ArrayList([]const u8) = .empty;
        defer args_list.deinit(allocator);
        if (obj.get("inputs")) |inputs| {
            if (inputs == .array) {
                for (inputs.array.items) |input| {
                    if (input != .object) continue;
                    if (input.object.get("type")) |type_value| {
                        if (type_value == .string) {
                            try args_list.append(allocator, type_value.string);
                        }
                    }
                }
            }
        }

        return try buildSignatureFromTypes(allocator, func_name, args_list.items);
    }

    return error.FunctionNotFound;
}

fn buildSignatureFromParams(allocator: std.mem.Allocator, name: []const u8, params: []const AbiParam) ![]u8 {
    var buffer: std.ArrayList(u8) = .empty;
    defer buffer.deinit(allocator);

    try buffer.appendSlice(allocator, name);
    try buffer.append(allocator, '(');
    for (params, 0..) |param, idx| {
        if (idx > 0) try buffer.append(allocator, ',');
        try buffer.appendSlice(allocator, param.abi_type);
    }
    try buffer.append(allocator, ')');
    return try buffer.toOwnedSlice(allocator);
}

fn buildSignatureFromTypes(allocator: std.mem.Allocator, name: []const u8, types: []const []const u8) ![]u8 {
    var buffer: std.ArrayList(u8) = .empty;
    defer buffer.deinit(allocator);

    try buffer.appendSlice(allocator, name);
    try buffer.append(allocator, '(');
    for (types, 0..) |t, idx| {
        if (idx > 0) try buffer.append(allocator, ',');
        try buffer.appendSlice(allocator, t);
    }
    try buffer.append(allocator, ')');
    return try buffer.toOwnedSlice(allocator);
}

fn castCallArgs(
    allocator: std.mem.Allocator,
    rpc_url: []const u8,
    address: []const u8,
    signature: []const u8,
    args: []const []const u8,
) ![]u8 {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "cast");
    try argv.append(allocator, "call");
    try argv.append(allocator, "--rpc-url");
    try argv.append(allocator, rpc_url);
    try argv.append(allocator, address);
    try argv.append(allocator, signature);
    for (args) |arg| {
        try argv.append(allocator, arg);
    }

    return try runCommandCapture(allocator, argv.items);
}

fn runCommandCapture(allocator: std.mem.Allocator, argv: []const []const u8) ![]u8 {
    var child = std.process.Child.init(argv, allocator);
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;

    try child.spawn();

    var stdout_buf: [64 * 1024]u8 = undefined;
    var stderr_buf: [64 * 1024]u8 = undefined;
    const stdout_len = child.stdout.?.readAll(&stdout_buf) catch 0;
    const stderr_len = child.stderr.?.readAll(&stderr_buf) catch 0;

    const term = try child.wait();
    if (term.Exited != 0) {
        const stderr = stderr_buf[0..stderr_len];
        const stdout = stdout_buf[0..stdout_len];
        std.debug.print("Command failed: {s}\n{s}\n{s}\n", .{ argv[0], stdout, stderr });
        return error.CommandFailed;
    }

    return try allocator.dupe(u8, stdout_buf[0..stdout_len]);
}

fn generateAbiWrapper(
    allocator: std.mem.Allocator,
    abi_path: []const u8,
    out_path: []const u8,
    module_name: []const u8,
) !void {
    const file = try std.fs.cwd().openFile(abi_path, .{});
    defer file.close();

    const json_bytes = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(json_bytes);

    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_bytes, .{});
    defer parsed.deinit();

    if (parsed.value != .array) return error.InvalidAbi;

    var functions: std.ArrayList(AbiFunction) = .empty;
    defer {
        for (functions.items) |func| func.deinit(allocator);
        functions.deinit(allocator);
    }

    for (parsed.value.array.items) |entry| {
        if (entry != .object) continue;
        const obj = entry.object;
        const type_field = obj.get("type") orelse continue;
        if (type_field != .string) continue;
        if (!std.mem.eql(u8, type_field.string, "function")) continue;

        const name_field = obj.get("name") orelse continue;
        if (name_field != .string) continue;

        const inputs = try parseAbiInputs(allocator, obj.get("inputs"));
        const outputs = try parseAbiTypes(allocator, obj.get("outputs"));
        const mutability = if (obj.get("stateMutability")) |mut| mut else std.json.Value{ .string = "nonpayable" };
        const mutability_str = if (mutability == .string) mutability.string else "nonpayable";

        try functions.append(allocator, .{
            .name = try allocator.dupe(u8, name_field.string),
            .inputs = inputs,
            .outputs = outputs,
            .state_mutability = try allocator.dupe(u8, mutability_str),
        });
    }

    var out: std.ArrayList(u8) = .empty;
    defer out.deinit(allocator);

    try out.appendSlice(allocator, "//! Generated by z2y abi-gen.\n");
    try out.appendSlice(allocator, "const evm = @import(\"evm.zig\");\n\n");

    try out.appendSlice(allocator, "pub const ");
    try out.appendSlice(allocator, module_name);
    try out.appendSlice(allocator, " = struct {\n");
    try out.appendSlice(allocator, "    address: evm.Address,\n\n");
    try out.appendSlice(allocator, "    pub fn init(address: evm.Address) ");
    try out.appendSlice(allocator, module_name);
    try out.appendSlice(allocator, " {\n        return .{ .address = address };\n    }\n\n");

    for (functions.items) |func| {
        try emitFunction(allocator, &out, func, module_name);
    }

    try out.appendSlice(allocator, "};\n");

    try std.fs.cwd().writeFile(.{ .sub_path = out_path, .data = out.items });
}

const AbiParam = struct {
    name: []const u8,
    abi_type: []const u8,

    fn deinit(self: *const AbiParam, allocator: std.mem.Allocator) void {
        allocator.free(self.name);
        allocator.free(self.abi_type);
    }
};

const AbiFunction = struct {
    name: []const u8,
    inputs: []AbiParam,
    outputs: [][]const u8,
    state_mutability: []const u8,

    fn deinit(self: *const AbiFunction, allocator: std.mem.Allocator) void {
        allocator.free(self.name);
        allocator.free(self.state_mutability);
        for (self.inputs) |input| input.deinit(allocator);
        allocator.free(self.inputs);
        for (self.outputs) |output| allocator.free(output);
        allocator.free(self.outputs);
    }
};

fn parseAbiInputs(allocator: std.mem.Allocator, value_opt: ?std.json.Value) ![]AbiParam {
    if (value_opt) |value| {
        if (value != .array) return error.InvalidAbi;
        var list: std.ArrayList(AbiParam) = .empty;
        defer list.deinit(allocator);

        for (value.array.items, 0..) |entry, idx| {
            if (entry != .object) continue;
            const obj = entry.object;
            const type_value = obj.get("type") orelse return error.InvalidAbi;
            if (type_value != .string) return error.InvalidAbi;

            var name_slice: []const u8 = "";
            if (obj.get("name")) |name_value| {
                if (name_value == .string) name_slice = name_value.string;
            }

            const chosen = try pickParamName(allocator, name_slice, idx, list.items);
            const abi_type = try allocator.dupe(u8, type_value.string);
            try list.append(allocator, .{ .name = chosen, .abi_type = abi_type });
        }

        return try list.toOwnedSlice(allocator);
    }
    return try allocator.alloc(AbiParam, 0);
}

fn parseAbiTypes(allocator: std.mem.Allocator, value_opt: ?std.json.Value) ![][]const u8 {
    if (value_opt) |value| {
        if (value != .array) return error.InvalidAbi;
        var list: std.ArrayList([]const u8) = .empty;
        defer list.deinit(allocator);
        for (value.array.items) |entry| {
            if (entry != .object) continue;
            if (entry.object.get("type")) |type_value| {
                if (type_value != .string) return error.InvalidAbi;
                try list.append(allocator, try allocator.dupe(u8, type_value.string));
            }
        }
        return try list.toOwnedSlice(allocator);
    }
    return try allocator.alloc([]const u8, 0);
}

fn appendFmt(out: *std.ArrayList(u8), allocator: std.mem.Allocator, comptime fmt: []const u8, args: anytype) !void {
    var buf: [64]u8 = undefined;
    const slice = try std.fmt.bufPrint(&buf, fmt, args);
    try out.appendSlice(allocator, slice);
}

fn pickParamName(allocator: std.mem.Allocator, raw_name: []const u8, index: usize, existing: []const AbiParam) ![]const u8 {
    const candidate = raw_name;
    if (candidate.len == 0) {
        return try std.fmt.allocPrint(allocator, "arg{d}", .{index});
    }

    for (existing) |item| {
        if (std.mem.eql(u8, item.name, candidate)) {
            return try std.fmt.allocPrint(allocator, "arg{d}", .{index});
        }
    }

    return try allocator.dupe(u8, candidate);
}

fn emitFunction(allocator: std.mem.Allocator, out: *std.ArrayList(u8), func: AbiFunction, module_name: []const u8) !void {
    const name_rendered = try formatIdentifier(allocator, func.name);
    defer allocator.free(name_rendered);

    try out.appendSlice(allocator, "    pub fn ");
    try out.appendSlice(allocator, name_rendered);
    try out.appendSlice(allocator, "(self: *");
    try out.appendSlice(allocator, module_name);

    if (func.inputs.len == 0) {
        try out.appendSlice(allocator, ") ");
    } else {
        try out.appendSlice(allocator, ", ");
        for (func.inputs, 0..) |input, idx| {
            const zig_type = try zigTypeForAbi(allocator, input.abi_type);
            defer allocator.free(zig_type);
            const rendered = try formatIdentifier(allocator, input.name);
            defer allocator.free(rendered);
            try out.appendSlice(allocator, rendered);
            try out.appendSlice(allocator, ": ");
            try out.appendSlice(allocator, zig_type);
            if (idx + 1 < func.inputs.len) {
                try out.appendSlice(allocator, ", ");
            }
        }
        try out.appendSlice(allocator, ") ");
    }

    try appendReturnType(allocator, out, func.outputs);
    try out.appendSlice(allocator, " {\n");

    try emitFunctionBody(allocator, out, func, module_name);

    try out.appendSlice(allocator, "    }\n\n");
}

fn appendReturnType(allocator: std.mem.Allocator, out: *std.ArrayList(u8), outputs: [][]const u8) !void {
    if (outputs.len == 0) {
        try out.appendSlice(allocator, "void");
        return;
    }
    if (outputs.len == 1) {
        const zig_type = try zigTypeForAbi(allocator, outputs[0]);
        defer allocator.free(zig_type);
        try out.appendSlice(allocator, zig_type);
        return;
    }
    return error.UnsupportedType;
}

fn emitFunctionBody(allocator: std.mem.Allocator, out: *std.ArrayList(u8), func: AbiFunction, module_name: []const u8) !void {
    _ = module_name;
    const signature = try buildSignatureFromParams(allocator, func.name, func.inputs);
    defer allocator.free(signature);

    try out.appendSlice(allocator, "        const selector = evm.abi.selectorWord(\"");
    try out.appendSlice(allocator, signature);
    try out.appendSlice(allocator, "\");\n");
    try out.appendSlice(allocator, "        evm.builtins.mstore(0x00, selector);\n");

    for (func.inputs, 0..) |input, idx| {
        try emitArgStore(allocator, out, input.abi_type, input.name, idx);
    }

    const call_kind = if (std.mem.eql(u8, func.state_mutability, "view") or std.mem.eql(u8, func.state_mutability, "pure")) "staticcall" else "call";

    const input_len = 4 + 32 * func.inputs.len;
    const output_len = 32 * func.outputs.len;

    try out.appendSlice(allocator, "        const ok = evm.builtins.");
    try out.appendSlice(allocator, call_kind);
    if (std.mem.eql(u8, call_kind, "staticcall")) {
        try out.appendSlice(allocator, "(evm.builtins.gas(), self.address, 0x00, ");
    } else {
        try out.appendSlice(allocator, "(evm.builtins.gas(), self.address, 0, 0x00, ");
    }
    try appendFmt(out, allocator, "0x{x}", .{input_len});
    try out.appendSlice(allocator, ", 0x00, ");
    try appendFmt(out, allocator, "0x{x}", .{output_len});
    try out.appendSlice(allocator, ");\n");
    try out.appendSlice(allocator, "        if (ok == 0) evm.builtins.revert(0, 0);\n");

    if (func.outputs.len == 0) {
        try out.appendSlice(allocator, "        return;\n");
        return;
    }

    if (func.outputs.len == 1) {
        try emitReturnDecode(allocator, out, func.outputs[0]);
        return;
    }

    return error.UnsupportedType;
}

fn emitArgStore(
    allocator: std.mem.Allocator,
    out: *std.ArrayList(u8),
    abi_type: []const u8,
    param_name: []const u8,
    index: usize,
) !void {
    const offset = 4 + 32 * index;
    const rendered = try formatIdentifier(allocator, param_name);
    defer allocator.free(rendered);

    if (std.mem.eql(u8, abi_type, "uint256") or std.mem.eql(u8, abi_type, "uint") or std.mem.eql(u8, abi_type, "address") or std.mem.eql(u8, abi_type, "bool")) {
        try out.appendSlice(allocator, "        evm.builtins.mstore(");
        try appendFmt(out, allocator, "0x{x}", .{offset});
        try out.appendSlice(allocator, ", ");
        try out.appendSlice(allocator, rendered);
        try out.appendSlice(allocator, ");\n");
        return;
    }
    if (std.mem.eql(u8, abi_type, "bytes32")) {
        try out.appendSlice(allocator, "        evm.builtins.mstore(");
        try appendFmt(out, allocator, "0x{x}", .{offset});
        try out.appendSlice(allocator, ", ");
        try out.appendSlice(allocator, rendered);
        try out.appendSlice(allocator, ");\n");
        return;
    }

    return error.UnsupportedType;
}

fn emitReturnDecode(allocator: std.mem.Allocator, out: *std.ArrayList(u8), abi_type: []const u8) !void {
    try out.appendSlice(allocator, "        return ");
    try emitLoadDecode(allocator, out, abi_type, 0);
    try out.appendSlice(allocator, ";\n");
}

fn emitLoadDecode(allocator: std.mem.Allocator, out: *std.ArrayList(u8), abi_type: []const u8, index: usize) !void {
    const offset = 32 * index;
    var buf: [32]u8 = undefined;
    const load_expr = try std.fmt.bufPrint(&buf, "evm.builtins.mload(0x{x})", .{offset});

    if (std.mem.eql(u8, abi_type, "uint256") or std.mem.eql(u8, abi_type, "uint")) {
        try out.appendSlice(allocator, load_expr);
        return;
    }
    if (std.mem.eql(u8, abi_type, "address")) {
        try out.appendSlice(allocator, "@intCast(");
        try out.appendSlice(allocator, load_expr);
        try out.appendSlice(allocator, ")");
        return;
    }
    if (std.mem.eql(u8, abi_type, "bool")) {
        try out.appendSlice(allocator, "(");
        try out.appendSlice(allocator, load_expr);
        try out.appendSlice(allocator, " != 0)");
        return;
    }
    if (std.mem.eql(u8, abi_type, "bytes32")) {
        try out.appendSlice(allocator, load_expr);
        return;
    }

    return error.UnsupportedType;
}

fn zigTypeForAbi(allocator: std.mem.Allocator, abi_type: []const u8) ![]const u8 {
    if (std.mem.eql(u8, abi_type, "uint256") or std.mem.eql(u8, abi_type, "uint")) {
        return allocator.dupe(u8, "evm.U256");
    }
    if (std.mem.eql(u8, abi_type, "address")) {
        return allocator.dupe(u8, "evm.Address");
    }
    if (std.mem.eql(u8, abi_type, "bool")) {
        return allocator.dupe(u8, "bool");
    }
    if (std.mem.eql(u8, abi_type, "bytes32")) {
        return allocator.dupe(u8, "evm.U256");
    }
    if (std.mem.startsWith(u8, abi_type, "uint")) {
        return allocator.dupe(u8, "evm.U256");
    }
    return error.UnsupportedType;
}

fn formatIdentifier(allocator: std.mem.Allocator, name: []const u8) ![]const u8 {
    var needs_escape = false;
    if (name.len == 0) return error.InvalidArgument;
    if (!std.ascii.isAlphabetic(name[0]) and name[0] != '_') needs_escape = true;
    for (name) |c| {
        if (!std.ascii.isAlphanumeric(c) and c != '_') {
            needs_escape = true;
            break;
        }
    }
    if (!needs_escape) return allocator.dupe(u8, name);

    return std.fmt.allocPrint(allocator, "@\"{s}\"", .{name});
}

fn readTrimmedFile(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    const data = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(data);

    const trimmed = std.mem.trim(u8, data, " \n\r\t");
    return try allocator.dupe(u8, trimmed);
}

fn extractContractAddress(output: []const u8) ?[]const u8 {
    const key = "\"contractAddress\":\"";
    const start = std.mem.indexOf(u8, output, key) orelse return null;
    const addr_start = start + key.len;
    const addr_end = std.mem.indexOfPos(u8, output, addr_start, "\"") orelse return null;
    return output[addr_start..addr_end];
}
