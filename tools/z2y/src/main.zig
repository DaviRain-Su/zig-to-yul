//! Source: z2y tool (no Rust reference)
const std = @import("std");

const Template = struct {
    const build_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const std = @import("std");
        \\
        \\pub fn build(b: *std.Build) void {
        \\    const target = b.standardTargetOptions(.{});
        \\    const optimize = b.standardOptimizeOption(.{});
        \\
        \\    const zig_to_yul = b.dependency("zig_to_yul", .{
        \\        .target = target,
        \\        .optimize = optimize,
        \\    });
        \\
        \\    const evm_mod = b.createModule(.{
        \\        .root_source_file = b.path("src/evm.zig"),
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .imports = &.{
        \\            .{ .name = "zig_to_yul", .module = zig_to_yul.module("zig_to_yul") },
        \\        },
        \\    });
        \\
        \\    // Provide root_source_file and module imports for --project.
        \\    const contract_mod = b.createModule(.{
        \\        .root_source_file = b.path("src/Contract.zig"),
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .imports = &.{
        \\            .{ .name = "evm", .module = evm_mod },
        \\        },
        \\    });
        \\    _ = contract_mod;
        \\
        \\    const compile_step = b.addSystemCommand(&.{
        \\        "zig-to-yul",
        \\        "compile",
        \\        "--project",
        \\        ".",
        \\        "--abi",
        \\        "contracts/Contract.abi.json",
        \\        "-o",
        \\        "contracts/Contract.yul",
        \\        "src/Contract.zig",
        \\    });
        \\
        \\    const solc_step = b.addSystemCommand(&.{
        \\        "solc",
        \\        "--strict-assembly",
        \\        "--bin",
        \\        "contracts/Contract.yul",
        \\        "-o",
        \\        "contracts",
        \\    });
        \\    solc_step.step.dependOn(&compile_step.step);
        \\
        \\    const contract_step = b.step("contract", "Build contract bytecode");
        \\    contract_step.dependOn(&solc_step.step);
        \\    b.getInstallStep().dependOn(&solc_step.step);
        \\}
    ;

    const build_zig_zon =
        \\// Generated by z2y. Use `zig fetch --save` to add dependencies.
        \\// See: https://ziglang.org/learn/build-system/#package-management
        \\.{
        \\    .name = .contract,
        \\    .version = "0.1.0",
        \\    .fingerprint = 0x0000000000000001,
        \\    .minimum_zig_version = "0.15.2",
        \\    .paths = .{"."},
        \\    .dependencies = .{
        \\        .zig_to_yul = .{
        \\            .url = "https://github.com/DaviRain-Su/zig-to-yul/archive/refs/heads/main.tar.gz",
        \\            .hash = "zig_to_yul-0.0.0-Gzz9gPBbCQCeGdLoAHlmk4bZvxtzRt1xWYqNsrVq4Eg1",
        \\        },
        \\    },
        \\}
    ;

    const evm_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const sdk = @import("zig_to_yul").evm;
        \\
        \\pub const types = sdk.types;
        \\pub const event_decode = sdk.event_decode;
        \\pub const event_encode = sdk.event_encode;
        \\pub const builtins = sdk.builtins;
        \\pub const U256 = sdk.U256;
        \\pub const Address = sdk.Address;
        \\pub const EvmType = sdk.EvmType;
    ;

    const contract_zig =
        \\//! Source: z2y template (no Rust reference)
        \\const evm = @import("evm");
        \\
        \\pub const Contract = struct {
        \\    value: u256,
        \\
        \\    pub fn set(self: *Contract, next: u256) void {
        \\        self.value = next;
        \\    }
        \\
        \\    pub fn get(self: *Contract) u256 {
        \\        return self.value;
        \\    }
        \\
        \\    pub fn add(self: *Contract, delta: u256) u256 {
        \\        self.value = self.value + delta;
        \\        return self.value;
        \\    }
        \\};
    ;
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        try printUsage();
        return;
    }

    const command = args[1];
    if (std.mem.eql(u8, command, "init")) {
        const target_dir = if (args.len >= 3) args[2] else ".";
        if (args.len > 3) {
            try printUsage();
            return;
        }
        try initProject(allocator, target_dir);
        return;
    }

    if (std.mem.eql(u8, command, "install")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try printInstallInstructions();
        return;
    }

    if (std.mem.eql(u8, command, "info")) {
        if (args.len > 2) {
            try printUsage();
            return;
        }
        try printToolInfo(allocator);
        return;
    }

    try printUsage();
}

fn printUsage() !void {
    var stdout_buffer: [1024]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;
    try stdout.print(
        "Usage:\n" ++
            "  z2y init [dir]\n" ++
            "  z2y install\n" ++
            "  z2y info\n",
        .{},
    );
    try stdout.flush();
}

fn printInstallInstructions() !void {
    const builtin = @import("builtin");
    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;

    try stdout.print("Required tools:\n", .{});
    try stdout.print("- Zig 0.15.x\n", .{});
    try stdout.print("- solc (Solidity compiler)\n", .{});
    try stdout.print("- zig-to-yul binary in PATH\n", .{});
    try stdout.print("- Foundry (anvil/forge)\n\n", .{});

    switch (builtin.os.tag) {
        .macos => {
            try stdout.print("Install Zig (macOS):\n  brew install zig\n", .{});
        },
        .linux => {
            try stdout.print("Install Zig (Linux):\n  https://ziglang.org/download/\n", .{});
        },
        .windows => {
            try stdout.print("Install Zig (Windows):\n  choco install zig\n", .{});
        },
        else => {
            try stdout.print("Install Zig:\n  https://ziglang.org/download/\n", .{});
        },
    }

    try stdout.print("\nInstall solc:\n  npm install -g solc\n", .{});
    try stdout.print("\nInstall Foundry (anvil/forge):\n  curl -L https://foundry.paradigm.xyz | bash\n  foundryup\n", .{});
    try stdout.print("\nInstall zig-to-yul (needed for compilation):\n  git clone git@github.com:DaviRain-Su/zig-to-yul.git\n  cd zig-to-yul\n  zig build -Doptimize=ReleaseFast\n\n", .{});
    try stdout.print("Add to PATH:\n  export PATH=\"$PWD/zig-out/bin:$PATH\"\n", .{});
    try stdout.flush();
}

fn printToolInfo(allocator: std.mem.Allocator) !void {
    var stdout_buffer: [2048]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const stdout: *std.Io.Writer = &stdout_writer.interface;

    try printToolStatus(allocator, stdout, "zig");
    try printToolStatus(allocator, stdout, "zig-to-yul");
    try printToolStatus(allocator, stdout, "solc");
    try printToolStatus(allocator, stdout, "anvil");
    try printToolStatus(allocator, stdout, "forge");
    try stdout.flush();
}

fn printToolStatus(allocator: std.mem.Allocator, stdout: *std.Io.Writer, name: []const u8) !void {
    const path = try findExecutablePath(allocator, name);
    defer if (path) |p| allocator.free(p);

    if (path) |p| {
        try stdout.print("{s}: found ({s})\n", .{ name, p });
    } else {
        try stdout.print("{s}: missing\n", .{name});
    }
}

fn findExecutablePath(allocator: std.mem.Allocator, name: []const u8) !?[]u8 {
    const builtin = @import("builtin");
    const path_value = std.process.getEnvVarOwned(allocator, "PATH") catch |err| switch (err) {
        error.EnvironmentVariableNotFound => return null,
        else => return err,
    };
    defer allocator.free(path_value);

    var it = std.mem.splitScalar(u8, path_value, std.fs.path.delimiter);
    while (it.next()) |dir| {
        if (dir.len == 0) continue;

        if (builtin.os.tag == .windows) {
            if (try checkExecutableCandidate(allocator, dir, name)) |found| return found;
            const exe_name = try std.fmt.allocPrint(allocator, "{s}.exe", .{name});
            defer allocator.free(exe_name);
            if (try checkExecutableCandidate(allocator, dir, exe_name)) |found| return found;
        } else {
            if (try checkExecutableCandidate(allocator, dir, name)) |found| return found;
        }
    }

    return null;
}

fn checkExecutableCandidate(allocator: std.mem.Allocator, dir: []const u8, name: []const u8) !?[]u8 {
    const path = try std.fs.path.join(allocator, &.{ dir, name });
    defer allocator.free(path);

    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {
        error.FileNotFound, error.NotDir, error.AccessDenied => return null,
        else => return err,
    };
    file.close();

    return try allocator.dupe(u8, path);
}

fn initProject(allocator: std.mem.Allocator, dir_path: []const u8) !void {
    var cwd = std.fs.cwd();
    if (dir_path.len > 0 and !std.mem.eql(u8, dir_path, ".")) {
        try cwd.makePath(dir_path);
    }

    var dir = try cwd.openDir(dir_path, .{ .iterate = true });
    defer dir.close();

    try dir.makePath("src");
    try dir.makePath("contracts");

    try dir.writeFile(.{ .sub_path = "build.zig", .data = Template.build_zig });
    try dir.writeFile(.{ .sub_path = "build.zig.zon", .data = Template.build_zig_zon });
    try dir.writeFile(.{ .sub_path = "src/Contract.zig", .data = Template.contract_zig });
    try dir.writeFile(.{ .sub_path = "src/evm.zig", .data = Template.evm_zig });

    try addDependency(allocator, dir);
}

fn addDependency(allocator: std.mem.Allocator, dir: std.fs.Dir) !void {
    var argv: std.ArrayList([]const u8) = .empty;
    defer argv.deinit(allocator);

    try argv.append(allocator, "zig");
    try argv.append(allocator, "fetch");
    try argv.append(allocator, "--save");
    try argv.append(allocator, "git@github.com:DaviRain-Su/zig-to-yul.git");

    var child = std.process.Child.init(argv.items, allocator);
    child.cwd_dir = dir;
    child.stdout_behavior = .Pipe;
    child.stderr_behavior = .Pipe;

    try child.spawn();

    var stdout_buf: [32 * 1024]u8 = undefined;
    var stderr_buf: [32 * 1024]u8 = undefined;
    const stdout_len = child.stdout.?.readAll(&stdout_buf) catch 0;
    const stderr_len = child.stderr.?.readAll(&stderr_buf) catch 0;

    const term = try child.wait();
    if (term.Exited != 0) {
        const stderr = stderr_buf[0..stderr_len];
        const stdout = stdout_buf[0..stdout_len];
        std.debug.print("zig fetch --save failed\n{s}\n{s}\n", .{ stdout, stderr });
        return error.DependencyFetchFailed;
    }
}
